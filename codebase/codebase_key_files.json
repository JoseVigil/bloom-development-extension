{
    "base": "C:/repos/bloom-videos/bloom-development-extension",
    "meta": {
        "origin": "Archivos espec√≠ficos: 14",
        "total": 17,
        "compressed": false,
        "format": "plain"
    },
    "usage": {
        "instruction": "Para archivos con \"c\" que inicia con \"gz:\", descomprimir con: gzip.decompress(base64.b64decode(content[3:]))",
        "example": "import gzip, base64; content = gzip.decompress(base64.b64decode(file[\"c\"][3:])).decode(\"utf-8\")"
    },
    "files": [
        {
            "p": "# Snapshot de Codebase",
            "l": "txt",
            "h": null,
            "c": ""
        },
        {
            "p": "package.json",
            "l": "json",
            "h": "551fc062",
            "c": "{\n  \"name\": \"bloom-btip-plugin\",\n  \"displayName\": \"Bloom BTIP\",\n  \"description\": \"Plugin para preview de Markdown y generaci√≥n de Technical Intent Packages\",\n  \"version\": \"1.1.0\",\n  \"publisher\": \"Jose Vigil\",\n  \"engines\": {\n    \"vscode\": \"^1.80.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onCommand:bloom.openMarkdownPreview\",\n    \"onCommand:bloom.generateIntent\",\n    \"onCommand:bloom.createNucleusProject\",\n    \"onCommand:bloom.linkToNucleus\",\n    \"onCommand:bloom.syncNucleusProjects\",\n    \"onView:bloomNucleus\",\n    \"onView:bloomNucleusWelcome\",\n    \"onView:bloomIntents\",\n    \"onView:bloomProfiles\",\n    \"onCommand:bloom.showWelcome\",\n    \"onCommand:bloom.manageProfiles\",\n    \"onCommand:bloom.openIntentInBrowser\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"contributes\": {\n    \"viewsContainers\": {\n      \"activitybar\": [\n        {\n          \"id\": \"bloomAiBridge\",\n          \"title\": \"Bloom Nucleus BTIPS\",\n          \"icon\": \"$(flame)\"\n        }\n      ]\n    },\n    \"views\": {\n      \"bloomAiBridge\": [\n        {\n          \"id\": \"bloomProfiles\",\n          \"name\": \"Chrome Profiles\",\n          \"contextualTitle\": \"AI Profiles\"\n        },\n        {\n          \"id\": \"bloomNucleusWelcome\",\n          \"name\": \"Nucleus\",\n          \"when\": \"!bloom.isRegistered\"\n        },\n        {\n          \"id\": \"bloomNucleus\",\n          \"name\": \"Nucleus\",\n          \"contextualTitle\": \"Organization Projects\",\n          \"when\": \"bloom.isRegistered\"\n        },\n        {\n          \"id\": \"bloomIntents\",\n          \"name\": \"Intents\"\n        }\n      ]\n    },\n    \"viewsWelcome\": [\n      {\n        \"view\": \"bloomNucleus\",\n        \"contents\": \"No hay ning√∫n Nucleus detectado en este workspace.\\n[Crear Nucleus](command:bloom.showWelcome)\",\n        \"when\": \"bloom.isRegistered && workspaceFolderCount > 0\"\n      },\n      {\n        \"view\": \"bloomNucleusWelcome\",\n        \"contents\": \"Bienvenido a Bloom Nucleus\\n\\nPara comenzar, complet√° tu registro gratuito.\\n[Conectar con GitHub](command:bloom.showWelcome)\",\n        \"when\": \"!bloom.isRegistered\"\n      }\n    ],\n    \"commands\": [\n      {\n        \"command\": \"bloom.openMarkdownPreview\",\n        \"title\": \"Bloom: Open Markdown Preview\"\n      },\n      {\n        \"command\": \"bloom.generateIntent\",\n        \"title\": \"Bloom: Generate New Intent\"\n      },\n      {\n        \"command\": \"bloom.openIntent\",\n        \"title\": \"Open Intent\"\n      },\n      {\n        \"command\": \"bloom.copyContextToClipboard\",\n        \"title\": \"Copy Context to Clipboard\",\n        \"icon\": \"$(clippy)\"\n      },\n      {\n        \"command\": \"bloom.deleteIntent\",\n        \"title\": \"Delete Intent\"\n      },\n      {\n        \"command\": \"bloom.addToIntent\",\n        \"title\": \"Bloom: Add to Intent\"\n      },\n      {\n        \"command\": \"bloom.deleteIntentFromForm\",\n        \"title\": \"Delete Current Intent\"\n      },\n      {\n        \"command\": \"bloom.openFileInVSCode\",\n        \"title\": \"Open File in VSCode\"\n      },\n      {\n        \"command\": \"bloom.revealInFinder\",\n        \"title\": \"Reveal in Finder/Explorer\"\n      },\n      {\n        \"command\": \"bloom.copyFilePath\",\n        \"title\": \"Copy File Path\"\n      },\n      {\n        \"command\": \"bloom.createBTIPProject\",\n        \"title\": \"Bloom: Create BTIP Project\"\n      },\n      {\n        \"command\": \"bloom.createNucleusProject\",\n        \"title\": \"Bloom: Crear Nucleus\",\n        \"icon\": \"$(add)\"\n      },\n      {\n        \"command\": \"bloom.linkToNucleus\",\n        \"title\": \"Bloom: Link to Nucleus\",\n        \"icon\": \"$(link)\"\n      },\n      {\n        \"command\": \"bloom.unlinkFromNucleus\",\n        \"title\": \"Bloom: Unlink from Nucleus\"\n      },\n      {\n        \"command\": \"bloom.openNucleusProject\",\n        \"title\": \"Bloom: Open Nucleus Project\",\n        \"icon\": \"$(folder-opened)\"\n      },\n      {\n        \"command\": \"bloom.syncNucleusProjects\",\n        \"title\": \"Bloom: Sync Nucleus Projects\",\n        \"icon\": \"$(sync)\"\n      },\n      {\n        \"command\": \"bloom.regenerateContext\",\n        \"title\": \"Bloom: Regenerate Project Context\"\n      },\n      {\n        \"command\": \"bloom.generateQuestions\",\n        \"title\": \"Bloom: Generate Questions\"\n      },\n      {\n        \"command\": \"bloom.submitAnswers\",\n        \"title\": \"Submit Answers to Claude\"\n      },\n      {\n        \"command\": \"bloom.integrateSnapshot\",\n        \"title\": \"Integrate Snapshot\"\n      },\n      {\n        \"command\": \"bloom.reloadIntentForm\",\n        \"title\": \"Reload Intent Form\"\n      },\n      {\n        \"command\": \"bloom.manageProfiles\",\n        \"title\": \"Bloom: Manage AI Profiles\",\n        \"icon\": \"$(account)\"\n      },\n      {\n        \"command\": \"bloom.refreshProfiles\",\n        \"title\": \"Refresh Profiles\",\n        \"icon\": \"$(refresh)\"\n      },\n      {\n        \"command\": \"bloom.configureIntentProfile\",\n        \"title\": \"Configure Profile for Intent\",\n        \"icon\": \"$(gear)\"\n      },\n      {\n        \"command\": \"bloom.openIntentInBrowser\",\n        \"title\": \"Bloom: Open Intent in Browser\",\n        \"icon\": \"$(browser)\"\n      },\n      {\n        \"command\": \"bloom.openClaudeInBrowser\",\n        \"title\": \"Bloom: Open Claude in Browser\"\n      },\n      {\n        \"command\": \"bloom.openChatGPTInBrowser\",\n        \"title\": \"Bloom: Open ChatGPT in Browser\"\n      },\n      {\n        \"command\": \"bloom.openGrokInBrowser\",\n        \"title\": \"Bloom: Open Grok in Browser\"\n      },\n      {\n        \"command\": \"bloom.showWelcome\",\n        \"title\": \"Bloom: Mostrar Bienvenida\"\n      },\n      {\n        \"command\": \"bloom.resetRegistration\",\n        \"title\": \"Bloom: Reset Registration (Debug)\"\n      },\n      {\n        \"command\": \"bloom.addProjectToNucleus\",\n        \"title\": \"Bloom: Agregar Proyecto\",\n        \"icon\": \"$(add)\"\n      },\n      {\n        \"command\": \"bloom.reviewPendingCommits\",\n        \"title\": \"Bloom: Revisar Commits Pendientes\",\n        \"icon\": \"$(git-commit)\"\n      },\n      {\n        \"command\": \"bloom.unlinkNucleus\",\n        \"title\": \"Bloom: Unlink Nucleus\",\n        \"icon\": \"$(chain-broken)\"\n      },\n      {\n        \"command\": \"bloom.refreshNucleus\",\n        \"title\": \"Refresh Nucleus\",\n        \"icon\": \"$(sync)\"\n      }\n    ],\n    \"menus\": {\n      \"view/title\": [\n        {\n          \"command\": \"bloom.refreshProfiles\",\n          \"when\": \"view == bloomProfiles\",\n          \"group\": \"navigation\"\n        },\n        {\n          \"command\": \"bloom.manageProfiles\",\n          \"when\": \"view == bloomProfiles\",\n          \"group\": \"navigation\"\n        },\n        {\n          \"command\": \"bloom.unlinkNucleus\",\n          \"when\": \"view == bloomNucleus\",\n          \"group\": \"navigation@0\"\n        },\n        {\n          \"command\": \"bloom.refreshNucleus\",\n          \"when\": \"view == bloomNucleus\",\n          \"group\": \"navigation\"\n        },\n        {\n          \"command\": \"bloom.createNucleusProject\",\n          \"when\": \"view == bloomNucleus && bloom.isRegistered\",\n          \"group\": \"navigation@1\"\n        },\n        {\n          \"command\": \"bloom.syncNucleusProjects\",\n          \"when\": \"view == bloomNucleus && bloom.isRegistered\",\n          \"group\": \"navigation@2\"\n        }\n      ],\n      \"explorer/context\": [\n        {\n          \"command\": \"bloom.generateIntent\",\n          \"when\": \"explorerResourceIsFolder || resourceScheme == file\",\n          \"group\": \"bloom@1\"\n        },\n        {\n          \"command\": \"bloom.addToIntent\",\n          \"when\": \"explorerResourceIsFolder || resourceScheme == file\",\n          \"group\": \"bloom@2\"\n        },\n        {\n          \"command\": \"bloom.createBTIPProject\",\n          \"when\": \"explorerResourceIsFolder\",\n          \"group\": \"bloom@3\"\n        },\n        {\n          \"command\": \"bloom.linkToNucleus\",\n          \"when\": \"explorerResourceIsFolder\",\n          \"group\": \"bloom@5\"\n        }\n      ],\n      \"commandPalette\": [\n        {\n          \"command\": \"bloom.regenerateContext\",\n          \"when\": \"workspaceFolderCount > 0\"\n        },\n        {\n          \"command\": \"bloom.createNucleusProject\",\n          \"when\": \"bloom.isRegistered\"\n        },\n        {\n          \"command\": \"bloom.linkToNucleus\",\n          \"when\": \"workspaceFolderCount > 0\"\n        },\n        {\n          \"command\": \"bloom.showWelcome\",\n          \"when\": \"true\"\n        },\n        {\n          \"command\": \"bloom.resetRegistration\",\n          \"when\": \"true\"\n        }\n      ],\n      \"view/item/context\": [\n        {\n          \"command\": \"bloom.addProjectToNucleus\",\n          \"when\": \"view == bloomNucleus && viewItem == nucleusOrg\",\n          \"group\": \"inline\"\n        },\n        {\n          \"command\": \"bloom.openIntent\",\n          \"when\": \"view == bloomIntents && viewItem == intent\",\n          \"group\": \"1_main@1\"\n        },\n        {\n          \"command\": \"bloom.copyContextToClipboard\",\n          \"when\": \"view == bloomIntents && viewItem == intent\",\n          \"group\": \"1_main@2\"\n        },\n        {\n          \"command\": \"bloom.configureIntentProfile\",\n          \"when\": \"view == bloomIntents && viewItem == intent\",\n          \"group\": \"2_profile@1\"\n        },\n        {\n          \"command\": \"bloom.openIntentInBrowser\",\n          \"when\": \"view == bloomIntents && viewItem == intent\",\n          \"group\": \"2_profile@2\"\n        },\n        {\n          \"command\": \"bloom.deleteIntent\",\n          \"when\": \"view == bloomIntents && viewItem == intent\",\n          \"group\": \"3_danger@1\"\n        },\n        {\n          \"command\": \"bloom.openNucleusProject\",\n          \"when\": \"view == bloomNucleus && viewItem == nucleusProject\",\n          \"group\": \"1_main@1\"\n        }\n      ]\n    },\n    \"keybindings\": [\n      {\n        \"command\": \"bloom.openIntentInBrowser\",\n        \"key\": \"ctrl+shift+b\",\n        \"mac\": \"cmd+shift+b\",\n        \"when\": \"editorFocus\"\n      },\n      {\n        \"command\": \"bloom.manageProfiles\",\n        \"key\": \"ctrl+alt+m\",\n        \"mac\": \"cmd+alt+m\"\n      },\n      {\n        \"command\": \"bloom.createNucleusProject\",\n        \"key\": \"ctrl+alt+n\",\n        \"mac\": \"cmd+alt+n\"\n      }\n    ],\n    \"configuration\": {\n      \"title\": \"Bloom\",\n      \"properties\": {\n        \"bloom.version\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"free\",\n            \"pro\"\n          ],\n          \"default\": \"free\",\n          \"description\": \"Versi√≥n del plugin\"\n        },\n        \"bloom.gitPath\": {\n          \"type\": \"string\",\n          \"default\": \"\",\n          \"description\": \"Ruta absoluta al ejecutable de Git (opcional, se detecta autom√°ticamente)\"\n        },\n        \"bloom.pythonPath\": {\n          \"type\": \"string\",\n          \"default\": \"python3\",\n          \"description\": \"Path al ejecutable de Python para scripts\"\n        },\n        \"bloom.useCustomCodebaseGenerator\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"Usar script Python personalizado para generar codebase.bl\"\n        },\n        \"bloom.claudeApiKey\": {\n          \"type\": \"string\",\n          \"default\": \"\",\n          \"description\": \"API Key de Claude (o usar variable de entorno ANTHROPIC_API_KEY)\"\n        },\n        \"bloom.claudeModel\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"claude-3-opus-20240229\",\n            \"claude-3-sonnet-20240229\"\n          ],\n          \"default\": \"claude-3-sonnet-20240229\",\n          \"description\": \"Modelo de Claude a utilizar\"\n        },\n        \"bloom.autoUpdateTree\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"Actualizar tree.txt autom√°ticamente despu√©s de cambios\"\n        },\n        \"bloom.nucleusAutoDetect\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"Detectar y mostrar proyectos Nucleus autom√°ticamente\"\n        }\n      }\n    }\n  },\n  \"extensions.autoCheckUpdates\": false,\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run build\",\n    \"compile\": \"tsc -p ./\",\n    \"copy-assets\": \"node -e \\\"require('fs').cpSync('src/ui', 'out/ui', {recursive: true})\\\"\",\n    \"build\": \"npm run compile && npm run copy-assets\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^18.19.130\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"@types/vscode\": \"^1.85.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.0\",\n    \"@typescript-eslint/parser\": \"^5.59.0\",\n    \"eslint\": \"^8.41.0\",\n    \"typescript\": \"^5.0.4\"\n  },\n  \"dependencies\": {\n    \"@google/generative-ai\": \"^0.24.1\",\n    \"@octokit/rest\": \"^22.0.1\",\n    \"@vscode/codicons\": \"^0.0.33\",\n    \"punycode\": \"^2.3.0\",\n    \"simple-git\": \"^3.30.0\",\n    \"uuid\": \"^13.0.0\"\n  }\n}\n"
        },
        {
            "p": "src/commands/manageProject.ts",
            "l": "typescript",
            "h": "262180a7",
            "c": ""
        },
        {
            "p": "Depende de:",
            "l": "txt",
            "h": null,
            "c": ""
        },
        {
            "p": "Es usado por:",
            "l": "txt",
            "h": null,
            "c": ""
        },
        {
            "p": "src/core/gitOrchestrator.ts",
            "l": "typescript",
            "h": "35117b2f",
            "c": "// src/core/gitOrchestrator.ts (fragmento con cambios clave)\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { GitExecutor } from '../utils/gitExecutor';\nimport { GitManager } from '../utils/gitManager';\nimport { WorkspaceManager } from '../managers/workspaceManager';\nimport { PythonScriptRunner } from './pythonScriptRunner';\n\nexport interface NucleusStatus {\n    exists: boolean;\n    location: 'local' | 'remote' | 'both' | 'none';\n    localPath?: string;\n    remoteUrl?: string;\n    hasValidStructure?: boolean;\n    conflictDetected?: boolean;\n}\n\nexport interface NucleusResult {\n    success: boolean;\n    nucleusPath: string;\n    action: 'created' | 'cloned' | 'linked';\n    message: string;\n    error?: string;\n}\n\nexport class GitOrchestrator {\n    static async detectNucleusStatus(\n        org: string,\n        parentPath: string\n    ): Promise<NucleusStatus> {\n        const nucleusName = `nucleus-${org}`;\n        const localPath = path.join(parentPath, nucleusName);\n        const remoteUrl = `https://github.com/${org}/${nucleusName}.git`;\n\n        console.log(`[GitOrchestrator] Detecting status for ${nucleusName}`);\n\n        // 1. Verificar existencia local\n        const localExists = fs.existsSync(localPath);\n\n        // 2. Verificar existencia remota\n        let remoteExists = false;\n        try {\n            const response = await fetch(`https://api.github.com/repos/${org}/${nucleusName}`);\n            remoteExists = response.ok;\n        } catch (error) {\n            console.warn('[GitOrchestrator] Could not check remote:', error);\n        }\n\n        // 3. Determinar ubicaci√≥n\n        let location: 'local' | 'remote' | 'both' | 'none';\n        if (localExists && remoteExists) {\n            location = 'both';\n        } else if (localExists) {\n            location = 'local';\n        } else if (remoteExists) {\n            location = 'remote';\n        } else {\n            location = 'none';\n        }\n\n        // 4. Validar estructura si existe local\n        let hasValidStructure = false;\n        if (localExists) {\n            hasValidStructure = this.validateBloomStructure(localPath);\n        }\n\n        console.log(`[GitOrchestrator] Status detected:`, {\n            location,\n            localExists,\n            remoteExists,\n            hasValidStructure\n        });\n\n        return {\n            exists: localExists || remoteExists,\n            location,\n            localPath: localExists ? localPath : undefined,\n            remoteUrl: remoteExists ? remoteUrl : undefined,\n            hasValidStructure,\n            conflictDetected: false\n        };\n    }\n\n    static async createNucleus(\n        org: string,\n        parentPath: string,\n        githubToken: string,\n        context: vscode.ExtensionContext,\n        logger: any\n    ): Promise<NucleusResult> {\n        const nucleusName = `nucleus-${org}`;\n        const nucleusPath = path.join(parentPath, nucleusName);\n        const repoUrl = `https://github.com/${org}/${nucleusName}.git`;\n\n        try {\n            console.log(`[GitOrchestrator] Creating Nucleus: ${nucleusName}`);\n\n            // 1. Crear directorio\n            if (!fs.existsSync(nucleusPath)) {\n                fs.mkdirSync(nucleusPath, { recursive: true });\n            }\n\n            // 2. Inicializar Git usando GitExecutor\n            console.log('[GitOrchestrator] Initializing git repository');\n            await GitExecutor.init(nucleusPath);\n\n            // 3. Crear repositorio en GitHub\n            console.log('[GitOrchestrator] Creating GitHub repository');\n            const createResponse = await fetch('https://api.github.com/user/repos', {\n                method: 'POST',\n                headers: {\n                    'Authorization': `token ${githubToken}`,\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/vnd.github.v3+json'\n                },\n                body: JSON.stringify({\n                    name: nucleusName,\n                    description: `Nucleus for ${org} organization`,\n                    private: false,\n                    auto_init: false\n                })\n            });\n\n            if (!createResponse.ok) {\n                const error = await createResponse.json();\n                throw new Error(`GitHub API error: ${error}`);\n            }\n\n            // 4. Agregar remote origin usando GitExecutor\n            console.log('[GitOrchestrator] Adding remote origin');\n            await GitExecutor.addRemote(nucleusPath, repoUrl);\n\n            // 5. Ejecutar script Python para generar estructura\n            console.log('[GitOrchestrator] Running Python script to generate structure');\n            await PythonScriptRunner.generateNucleusStructure(nucleusPath, org, {\n                url: repoUrl\n            });\n\n            // 6. Inicializar workspace file DENTRO del Nucleus\n            console.log('[GitOrchestrator] Creating workspace file');\n            const workspaceFilePath = await WorkspaceManager.initializeWorkspace(\n                nucleusPath,\n                org\n            );\n\n            // 7. Stage cambios usando GitManager (universal)\n            console.log('[GitOrchestrator] Staging changes');\n            await GitManager.stageAndOpenSCM(\n                nucleusPath,\n                undefined,\n                `Initial commit for ${nucleusName}`\n            );\n\n            // 8. Ofrecer abrir workspace\n            await this.promptOpenWorkspace(workspaceFilePath, org);\n\n            return {\n                success: true,\n                nucleusPath,\n                action: 'created',\n                message: `‚úÖ Nucleus creado: ${nucleusName}`\n            };\n\n        } catch (error: any) {\n            console.error('[GitOrchestrator] Error creating Nucleus:', error);\n            return {\n                success: false,\n                nucleusPath,\n                action: 'created',\n                message: `‚ùå Error creando Nucleus`,\n                error: error.message\n            };\n        }\n    }\n\n    static async cloneNucleus(\n        org: string,\n        parentPath: string\n    ): Promise<NucleusResult> {\n        const nucleusName = `nucleus-${org}`;\n        const nucleusPath = path.join(parentPath, nucleusName);\n        const repoUrl = `https://github.com/${org}/${nucleusName}.git`;\n\n        try {\n            console.log(`[GitOrchestrator] Cloning Nucleus: ${nucleusName}`);\n\n            // Progress handler\n            const progressHandler = (data: string) => {\n                console.log(`[Git Clone] ${data}`);\n            };\n\n            // Clonar usando GitExecutor\n            await GitExecutor.clone(repoUrl, nucleusPath, progressHandler);\n\n            // Verificar estructura\n            const hasValidStructure = this.validateBloomStructure(nucleusPath);\n\n            if (!hasValidStructure) {\n                console.log('[GitOrchestrator] Structure incomplete, completing...');\n                await PythonScriptRunner.generateNucleusStructure(nucleusPath, org, {\n                    skipExisting: true\n                });\n\n                // Stage cambios si se complet√≥ la estructura\n                await GitManager.stageAndOpenSCM(\n                    nucleusPath,\n                    undefined,\n                    'Complete Nucleus structure'\n                );\n            }\n\n            // Verificar workspace file\n            if (!WorkspaceManager.hasWorkspaceFile(nucleusPath, org)) {\n                console.log('[GitOrchestrator] Creating workspace file');\n                await WorkspaceManager.initializeWorkspace(nucleusPath, org);\n            }\n\n            const workspaceFilePath = WorkspaceManager.getWorkspaceFilePath(nucleusPath, org);\n            await this.promptOpenWorkspace(workspaceFilePath, org);\n\n            return {\n                success: true,\n                nucleusPath,\n                action: 'cloned',\n                message: `‚úÖ Nucleus clonado: ${nucleusName}`\n            };\n\n        } catch (error: any) {\n            console.error('[GitOrchestrator] Error cloning Nucleus:', error);\n            return {\n                success: false,\n                nucleusPath,\n                action: 'cloned',\n                message: `‚ùå Error clonando Nucleus`,\n                error: error.message\n            };\n        }\n    }\n\n    static async linkNucleus(\n        localPath: string,\n        org: string\n    ): Promise<NucleusResult> {\n        try {\n            console.log(`[GitOrchestrator] Linking Nucleus at: ${localPath}`);\n\n            const nucleusName = path.basename(localPath);\n            const repoUrl = `https://github.com/${org}/${nucleusName}.git`;\n\n            // Verificar que es un repo git\n            const isRepo = await GitExecutor.isGitRepository(localPath);\n\n            if (!isRepo) {\n                console.log('[GitOrchestrator] Not a git repo, initializing...');\n                await GitExecutor.init(localPath);\n            }\n\n            // Verificar remote origin\n            const hasRemote = await GitExecutor.hasRemote(localPath, 'origin');\n\n            if (!hasRemote) {\n                console.log('[GitOrchestrator] Adding remote origin');\n                await GitExecutor.addRemote(localPath, repoUrl);\n            } else {\n                const currentRemote = await GitExecutor.getRemoteUrl(localPath, 'origin');\n                if (currentRemote !== repoUrl) {\n                    console.warn('[GitOrchestrator] Remote URL mismatch!');\n                    // Aqu√≠ podr√≠as ofrecer actualizar el remote\n                }\n            }\n\n            // Completar estructura si falta\n            const hasValidStructure = this.validateBloomStructure(localPath);\n            if (!hasValidStructure) {\n                console.log('[GitOrchestrator] Completing structure...');\n                await PythonScriptRunner.generateNucleusStructure(localPath, org, {\n                    skipExisting: true\n                });\n            }\n\n            // Verificar workspace file\n            if (!WorkspaceManager.hasWorkspaceFile(localPath, org)) {\n                await WorkspaceManager.initializeWorkspace(localPath, org);\n            }\n\n            // Stage cambios si los hay\n            await GitManager.stageAndOpenSCM(\n                localPath,\n                undefined,\n                'Link Nucleus to GitHub'\n            );\n\n            return {\n                success: true,\n                nucleusPath: localPath,\n                action: 'linked',\n                message: `‚úÖ Nucleus vinculado: ${nucleusName}`\n            };\n\n        } catch (error: any) {\n            console.error('[GitOrchestrator] Error linking Nucleus:', error);\n            return {\n                success: false,\n                nucleusPath: localPath,\n                action: 'linked',\n                message: `‚ùå Error vinculando Nucleus`,\n                error: error.message\n            };\n        }\n    }\n\n    private static validateBloomStructure(nucleusPath: string): boolean {\n        const requiredPaths = [\n            '.bloom',\n            '.bloom/core',\n            '.bloom/core/nucleus-config.json',\n            '.bloom/organization',\n            '.bloom/projects'\n        ];\n\n        return requiredPaths.every(p =>\n            fs.existsSync(path.join(nucleusPath, p))\n        );\n    }\n\n    private static async promptOpenWorkspace(\n        workspaceFilePath: string,\n        orgName: string\n    ): Promise<void> {\n        const action = await vscode.window.showInformationMessage(\n            `‚úÖ Nucleus listo para ${orgName}`,\n            {\n                modal: false,\n                detail: 'Tu Nucleus est√° configurado. ¬øQuer√©s abrir el workspace?'\n            },\n            'Abrir Workspace',\n            'M√°s Tarde'\n        );\n\n        if (action === 'Abrir Workspace') {\n            await WorkspaceManager.openWorkspace(workspaceFilePath);\n        }\n    }\n}"
        },
        {
            "p": "src/core/intentSession.ts",
            "l": "typescript",
            "h": "2cd00f51",
            "c": "import * as vscode from 'vscode';\nimport { EventEmitter } from 'events';\nimport { MetadataManager } from './metadataManager';\nimport { CodebaseGenerator } from './codebaseGenerator';\nimport { IntentGenerator } from './intentGenerator';\nimport { IntentAutoSaver } from './intentAutoSaver';\nimport { Logger } from '../utils/logger';\nimport { IntentFormData, IntentContent, TokenStats, formDataToContent, IntentWorkflow, IntentWorkflowStage } from '../models/intent';\nimport { FileDescriptor, FileCategory } from '../models/codebaseStrategy';\nimport { joinPath } from '../utils/uriHelper';\nimport * as path from 'path';\n\nexport interface IntentState {\n    id: string;\n    name: string;\n    status: 'draft' | 'in-progress' | 'completed' | 'archived';\n    files: string[];\n    content: IntentContent;\n    tokens: TokenStats;\n    workflow: IntentWorkflow;\n    projectType?: string;\n    intentFolder: vscode.Uri;\n}\n\nexport class IntentSession extends EventEmitter {\n    private autoSaver: IntentAutoSaver;\n    private state: IntentState;\n\n    private constructor(\n        private intentFolder: vscode.Uri,\n        private workspaceFolder: vscode.WorkspaceFolder,\n        private metadataManager: MetadataManager,\n        private codebaseGenerator: CodebaseGenerator,\n        private intentGenerator: IntentGenerator,\n        private logger: Logger,\n        initialState: IntentState\n    ) {\n        super();\n        this.state = initialState;\n        this.autoSaver = new IntentAutoSaver(\n            intentFolder,\n            workspaceFolder,\n            metadataManager,\n            codebaseGenerator,\n            logger\n        );\n    }\n\n    static async create(\n        intentFolder: vscode.Uri,\n        workspaceFolder: vscode.WorkspaceFolder,\n        selectedFiles: vscode.Uri[],\n        relativePaths: string[],\n        metadataManager: MetadataManager,\n        codebaseGenerator: CodebaseGenerator,\n        intentGenerator: IntentGenerator,\n        logger: Logger\n    ): Promise<IntentSession> {\n        const initialState: IntentState = {\n            id: '',\n            name: '',\n            status: 'draft',\n            files: relativePaths,\n            content: {\n                problem: '',\n                expectedOutput: '',\n                currentBehavior: [],\n                desiredBehavior: [],\n                considerations: ''\n            },\n            tokens: {\n                estimated: 0,\n                limit: 100000,\n                percentage: 0\n            },\n            workflow: {\n                stage: 'draft',\n                questions: [],\n                integrationStatus: 'pending'\n            },\n            intentFolder: intentFolder\n        };\n\n        const session = new IntentSession(\n            intentFolder,\n            workspaceFolder,\n            metadataManager,\n            codebaseGenerator,\n            intentGenerator,\n            logger,\n            initialState\n        );\n\n        await session.calculateTokens();\n\n        return session;\n    }\n\n    static async forIntent(\n        intentName: string,\n        workspaceFolder: vscode.WorkspaceFolder,\n        metadataManager: MetadataManager,\n        codebaseGenerator: CodebaseGenerator,\n        intentGenerator: IntentGenerator,\n        logger: Logger\n    ): Promise<IntentSession> {\n        const intentFolder = vscode.Uri.file(\n            path.join(workspaceFolder.uri.fsPath, '.bloom', 'intents', intentName)\n        );\n\n        const metadata = await metadataManager.read(intentFolder);\n        if (!metadata) {\n            throw new Error(`Intent '${intentName}' not found`);\n        }\n\n        const state: IntentState = {\n            id: metadata.id,\n            name: metadata.name,\n            status: metadata.status,\n            files: metadata.files.filesIncluded || [],\n            content: metadata.content,\n            tokens: metadata.tokens,\n            workflow: metadata.workflow || {\n                stage: 'draft',\n                questions: [],\n                integrationStatus: 'pending'\n            },\n            projectType: metadata.projectType,\n            intentFolder: intentFolder\n        };\n\n        return new IntentSession(\n            intentFolder,\n            workspaceFolder,\n            metadataManager,\n            codebaseGenerator,\n            intentGenerator,\n            logger,\n            state\n        );\n    }\n\n    async updateWorkflow(updates: Partial<IntentWorkflow>): Promise<void> {\n        this.state.workflow = {\n            ...this.state.workflow,\n            ...updates\n        };\n\n        await this.metadataManager.update(this.intentFolder, {\n            workflow: this.state.workflow\n        });\n\n        this.emit('workflowChanged', this.state.workflow);\n    }\n\n    async readIntentFile(): Promise<string> {\n        const intentPath = joinPath(this.intentFolder, 'intent.bl');\n        const content = await vscode.workspace.fs.readFile(intentPath);\n        return new TextDecoder().decode(content);\n    }\n\n    async readCodebaseFile(): Promise<string> {\n        const codebasePath = joinPath(this.intentFolder, 'codebase.bl');\n        const content = await vscode.workspace.fs.readFile(codebasePath);\n        return new TextDecoder().decode(content);\n    }\n\n    async readSnapshotFile(): Promise<string> {\n        if (!this.state.workflow.snapshotPath) {\n            throw new Error('No snapshot path available');\n        }\n        const snapshotPath = vscode.Uri.file(this.state.workflow.snapshotPath);\n        const content = await vscode.workspace.fs.readFile(snapshotPath);\n        return new TextDecoder().decode(content);\n    }\n\n    getWorkflowStage(): IntentWorkflowStage {\n        return this.state.workflow?.stage || 'draft';\n    }\n\n    getIntentFolder(): vscode.Uri {\n        return this.intentFolder;\n    }\n\n    getWorkspaceFolder(): vscode.WorkspaceFolder {\n        return this.workspaceFolder;\n    }\n\n    async addFiles(files: vscode.Uri[]): Promise<void> {\n        this.logger.info(`Adding ${files.length} files to intent`);\n\n        const newRelativePaths = files.map(file =>\n            path.relative(this.workspaceFolder.uri.fsPath, file.fsPath)\n        );\n\n        this.state.files = [...new Set([...this.state.files, ...newRelativePaths])];\n\n        await this.metadataManager.update(this.intentFolder, {\n            files: {\n                intentFile: 'intent.bl',\n                codebaseFile: 'codebase.bl',\n                filesIncluded: this.state.files,\n                filesCount: this.state.files.length,\n                totalSize: await this.calculateTotalSize()\n            }\n        });\n\n        await this.regenerateCodebase();\n        await this.calculateTokens();\n\n        this.emit('filesChanged', this.state.files);\n        this.logger.info(`Files added successfully`);\n    }\n\n    async removeFile(filePath: string): Promise<void> {\n        this.logger.info(`Removing file: ${filePath}`);\n\n        this.state.files = this.state.files.filter(f => f !== filePath);\n\n        await this.metadataManager.update(this.intentFolder, {\n            files: {\n                intentFile: 'intent.bl',\n                codebaseFile: 'codebase.bl',\n                filesIncluded: this.state.files,\n                filesCount: this.state.files.length,\n                totalSize: await this.calculateTotalSize()\n            }\n        });\n\n        await this.regenerateCodebase();\n        await this.calculateTokens();\n\n        this.emit('filesChanged', this.state.files);\n        this.logger.info(`File removed successfully`);\n    }\n\n    async generateIntent(formData: IntentFormData): Promise<void> {\n        this.logger.info('Generating intent.bl');\n\n        this.state.name = formData.name;\n        this.state.content = formDataToContent(formData);\n\n        const intentPath = joinPath(this.intentFolder, 'intent.bl');\n        await this.intentGenerator.generateIntent(\n            formData,\n            this.state.files,\n            intentPath\n        );\n\n        await this.regenerateCodebase();\n\n        await this.updateWorkflow({\n            stage: 'intent-generated'\n        });\n\n        await this.changeStatus('completed');\n\n        this.logger.info('Intent generated successfully');\n    }\n\n    async regenerateIntent(formData: IntentFormData): Promise<void> {\n        this.logger.info('Regenerating intent.bl');\n\n        this.state.content = formDataToContent(formData);\n\n        const intentPath = joinPath(this.intentFolder, 'intent.bl');\n        await this.intentGenerator.generateIntent(\n            formData,\n            this.state.files,\n            intentPath\n        );\n\n        await this.regenerateCodebase();\n\n        await this.metadataManager.update(this.intentFolder, {\n            content: this.state.content\n        });\n\n        this.logger.info('Intent regenerated successfully');\n    }\n\n    queueAutoSave(updates: Partial<IntentContent>): void {\n        Object.assign(this.state.content, updates);\n        this.autoSaver.enqueue(updates);\n        this.emit('stateChanged', this.state);\n    }\n\n    async changeStatus(status: 'draft' | 'in-progress' | 'completed' | 'archived'): Promise<void> {\n        this.state.status = status;\n        await this.metadataManager.update(this.intentFolder, {\n            status\n        });\n        this.emit('stateChanged', this.state);\n    }\n\n    async deleteIntent(): Promise<void> {\n        this.logger.info(`Deleting intent: ${this.state.name}`);\n\n        await vscode.workspace.fs.delete(this.intentFolder, { recursive: true });\n\n        this.dispose();\n        this.logger.info('Intent deleted successfully');\n    }\n\n    getState(): IntentState {\n        return { ...this.state };\n    }\n\n    private async regenerateCodebase(): Promise<void> {\n        this.logger.info('Regenerating codebase.bl');\n\n        await vscode.workspace.fs.createDirectory(this.intentFolder);\n\n        try {\n            await vscode.workspace.fs.stat(this.intentFolder);\n        } catch {\n            // Crear carpeta si no existe\n            await vscode.workspace.fs.createDirectory(this.intentFolder);\n            this.logger.info(`Created intent folder: ${this.intentFolder.fsPath}`);\n        }\n\n        const fileDescriptors: FileDescriptor[] = this.state.files.map(relativePath => {\n            const absolutePath = path.join(this.workspaceFolder.uri.fsPath, relativePath);\n            return {\n                relativePath,\n                absolutePath,\n                category: this.categorizeFile(relativePath),\n                priority: 1,\n                size: 0,\n                extension: path.extname(relativePath),\n                metadata: {\n                    size: 0,\n                    type: path.extname(relativePath).slice(1),\n                    lastModified: Date.now()\n                }\n            };\n        });\n\n        const codebasePath = joinPath(this.intentFolder, 'codebase.bl');\n\n        await this.codebaseGenerator.generate(\n            fileDescriptors,\n            codebasePath,\n            {\n                workspaceFolder: this.workspaceFolder,\n                format: 'markdown',\n                includeMetadata: true,\n                addTableOfContents: true,\n                categorizeByType: false\n            }\n        );\n\n        this.logger.info('Codebase regenerated');\n    }\n\n    private categorizeFile(filePath: string): FileCategory {\n        const ext = path.extname(filePath).toLowerCase();\n\n        if (['.ts', '.tsx', '.js', '.jsx', '.py', '.java', '.kt', '.swift'].includes(ext)) {\n            return 'code';\n        }\n        if (['.json', '.yaml', '.yml', '.toml', '.ini', '.env'].includes(ext)) {\n            return 'config';\n        }\n        if (['.md', '.txt', '.rst'].includes(ext)) {\n            return 'docs';\n        }\n        if (filePath.includes('.test.') || filePath.includes('.spec.')) {\n            return 'test';\n        }\n        if (['.png', '.jpg', '.svg', '.ico'].includes(ext)) {\n            return 'asset';\n        }\n        return 'other';\n    }\n\n    private async calculateTokens(): Promise<void> {\n        let totalChars = 0;\n\n        for (const relativePath of this.state.files) {\n            const fileUri = vscode.Uri.file(\n                path.join(this.workspaceFolder.uri.fsPath, relativePath)\n            );\n            try {\n                const content = await vscode.workspace.fs.readFile(fileUri);\n                totalChars += content.length;\n            } catch (error) {\n                this.logger.warn(`Error reading file ${relativePath}: ${error}`);\n            }\n        }\n\n        totalChars += this.state.content.problem.length;\n        totalChars += this.state.content.expectedOutput.length;\n        totalChars += this.state.content.considerations.length;\n\n        const estimated = Math.ceil(totalChars / 4);\n        const percentage = (estimated / this.state.tokens.limit) * 100;\n\n        this.state.tokens = {\n            estimated,\n            limit: 100000,\n            percentage: Math.round(percentage * 100) / 100\n        };\n\n        await this.metadataManager.update(this.intentFolder, {\n            tokens: this.state.tokens\n        });\n\n        this.emit('tokensChanged', this.state.tokens);\n    }\n\n    private async calculateTotalSize(): Promise<number> {\n        let total = 0;\n        for (const relativePath of this.state.files) {\n            const fileUri = vscode.Uri.file(\n                path.join(this.workspaceFolder.uri.fsPath, relativePath)\n            );\n            try {\n                const stat = await vscode.workspace.fs.stat(fileUri);\n                total += stat.size;\n            } catch (error) {\n                this.logger.warn(`Error calculating size for ${relativePath}`);\n            }\n        }\n        return total;\n    }\n\n    dispose(): void {\n        this.autoSaver.dispose();\n        this.removeAllListeners();\n    }\n}"
        },
        {
            "p": "src/core/nucleusManager.ts",
            "l": "typescript",
            "h": "23f3165a",
            "c": "// src/core/nucleusManager.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { Logger } from '../utils/logger';\nimport { getCurrentGitHubUser, getGitHubHeaders } from '../utils/githubOAuth';\n\nconst execAsync = promisify(exec);\n\nexport class NucleusManager {\n    private logger: Logger;\n\n    constructor(private context: vscode.ExtensionContext) {\n        this.logger = new Logger();\n    }\n\n    async createOrLinkNucleus(org: string, localPath: string, isNew: boolean): Promise<string> {\n        const repoName = `nucleus-${org}`;\n        const user = await getCurrentGitHubUser();\n        const headers = await getGitHubHeaders();\n\n        // Check if repo exists in GitHub\n        const repoUrl = `https://github.com/${org}/${repoName}`;\n        const checkResp = await fetch(`https://api.github.com/repos/${org}/${repoName}`, { headers });\n        const existsInGitHub = checkResp.ok;\n\n        if (isNew) {\n            if (existsInGitHub) throw new Error('Repo ya existe en GitHub');\n\n            // Create new repo\n            const createResp = await fetch(`https://api.github.com/orgs/${org}/repos`, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify({\n                    name: repoName,\n                    description: 'Bloom Nucleus Project',\n                    private: false,\n                    auto_init: true\n                })\n            });\n            if (!createResp.ok) throw new Error('Error creando repo');\n\n            // Clone locally\n            await execAsync(`git clone ${repoUrl} \"${localPath}\"`);\n            this.logger.info(`Nucleus creado y clonado en ${localPath}`);\n\n        } else {\n            if (!existsInGitHub) throw new Error('Repo no existe en GitHub');\n\n            // Clone or link existing local\n            if (!fs.existsSync(localPath)) {\n                await execAsync(`git clone ${repoUrl} \"${localPath}\"`);\n                this.logger.info(`Nucleus clonado en ${localPath}`);\n            } else {\n                // Link if local exists\n                const gitDir = path.join(localPath, '.git');\n                if (fs.existsSync(gitDir)) {\n                    this.logger.info(`Nucleus linkeado en ${localPath}`);\n                } else {\n                    throw new Error('Carpeta no es un repo Git v√°lido');\n                }\n            }\n        }\n\n        // Open in new window\n        const open = await vscode.window.showQuickPick(['S√≠', 'No'], { placeHolder: '¬øAbrir en nueva ventana?' });\n        if (open === 'S√≠') {\n            await vscode.commands.executeCommand('vscode.openFolder', vscode.Uri.file(localPath), true);\n        }\n\n        return localPath;\n    }\n\n    async detectExistingNucleus(): Promise<string | null> {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n        if (!workspaceFolder) return null;\n\n        const nucleusPath = path.join(workspaceFolder, '.bloom', 'core', 'nucleus-config.json');\n        if (fs.existsSync(nucleusPath)) {\n            return workspaceFolder;\n        }\n\n        // Buscar en parent folders or linked\n        return null;\n    }\n}"
        },
        {
            "p": "src/extension.ts",
            "l": "typescript",
            "h": "5401bd47",
            "c": "// src/extension.ts\nimport * as vscode from 'vscode';\nimport { Logger } from './utils/logger';\nimport { initializeContext } from './initialization/contextInitializer';\nimport { initializeProviders } from './initialization/providersInitializer';\nimport { initializeManagers } from './initialization/managersInitializer';\nimport { registerAllCommands } from './initialization/commandRegistry';\nimport { registerCriticalCommands } from './initialization/criticalCommandsInitializer';\n\nexport function activate(context: vscode.ExtensionContext) {\n    const logger = new Logger();\n    logger.info('üå∏ Bloom BTIP + Nucleus Premium activando...');\n\n    try {\n        // 1. Inicializar contexto global\n        const isRegistered = initializeContext(context, logger);\n\n        // 2. Inicializar managers\n        const managers = initializeManagers(context, logger);\n\n        // 3. Verificar workspace\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n\n        if (!workspaceFolder) {\n            logger.warn('‚ö†Ô∏è No workspace folder - Limited functionality');\n            registerCriticalCommands(context, logger, managers.welcomeView);\n            return;\n        }\n\n        // 4. Inicializar providers\n        const providers = initializeProviders(context, workspaceFolder, logger, managers);\n\n        // 5. Registrar TODOS los comandos\n        registerAllCommands(context, logger, managers, providers);\n\n        // 6. Mostrar welcome si es primera vez\n        if (!isRegistered) {\n            logger.info('üìã Primera instalaci√≥n - Mostrando Welcome');\n            setTimeout(() => {\n                try {\n                    managers.welcomeView.show();\n                } catch (error: any) {\n                    logger.error('Error showing welcome', error);\n                }\n            }, 1000);\n        }\n\n        logger.info('‚úÖ Bloom BTIP activation complete');\n\n    } catch (error: any) {\n        logger.error('‚ùå Critical error during activation', error);\n        vscode.window.showErrorMessage(\n            `Bloom BTIP fall√≥ al activarse: ${error.message}`\n        );\n    }\n}\n\nexport function deactivate() {\n    // VSCode limpia autom√°ticamente\n}"
        },
        {
            "p": "src/initialization/commandRegistry.ts",
            "l": "typescript",
            "h": "61553cd5",
            "c": "// src/initialization/commandRegistry.ts\nimport * as vscode from 'vscode';\nimport { Logger } from '../utils/logger';\nimport { Managers } from './managersInitializer';\nimport { Providers } from './providersInitializer';\n\n// Importar comandos b√°sicos de intents\nimport { registerOpenMarkdownPreview } from '../commands/openMarkdownPreview';\nimport { registerGenerateIntent } from '../commands/generateIntent';\nimport { registerOpenIntent } from '../commands/openIntent';\nimport { registerCopyContextToClipboard } from '../commands/copyContextToClipboard';\nimport { registerDeleteIntent } from '../commands/deleteIntent';\nimport { registerAddToIntent } from '../commands/addToIntent';\nimport { registerDeleteIntentFromForm } from '../commands/deleteIntentFromForm';\nimport { registerOpenFileInVSCode } from '../commands/openFileInVSCode';\nimport { registerRevealInFinder } from '../commands/revealInFinder';\nimport { registerCreateBTIPProject } from '../commands/createBTIPProject';\nimport { registerGenerateQuestions } from '../commands/generateQuestions';\nimport { registerSubmitAnswers } from '../commands/submitAnswers';\nimport { registerIntegrateSnapshot } from '../commands/integrateSnapshot';\nimport { registerReloadIntentForm } from '../commands/reloadIntentForm';\nimport { registerRegenerateContext } from '../commands/regenerateContext';\n\n// Importar comandos de nucleus y profiles\nimport { registerNucleusCommands } from '../commands/nucleus/nucleusCommands';\nimport { registerProfileCommands } from '../commands/profile/profileCommands';\nimport { registerGitCommands } from '../commands/git/gitCommands';\nimport { registerDebugCommands } from '../commands/debug/debugCommands';\n\nexport function registerAllCommands(\n    context: vscode.ExtensionContext,\n    logger: Logger,\n    managers: Managers,\n    providers: Providers\n): void {\n    logger.info('üìù Registrando comandos...');\n\n    // ========================================\n    // CATEGOR√çA 1: COMANDOS DE INTENTS\n    // ========================================\n    registerOpenMarkdownPreview(context, logger);\n    registerGenerateIntent(context, logger);\n    registerOpenIntent(context, logger, managers.metadataManager);\n    registerCopyContextToClipboard(context, logger, managers.contextGatherer);\n    registerDeleteIntent(context, logger, providers.intentTreeProvider);\n    registerAddToIntent(context, logger);\n    registerDeleteIntentFromForm(context, logger);\n    registerOpenFileInVSCode(context, logger);\n    registerRevealInFinder(context, logger);\n    registerCreateBTIPProject(context, logger);\n    registerGenerateQuestions(context, logger);\n    registerSubmitAnswers(context, logger);\n    registerIntegrateSnapshot(context, logger);\n    registerReloadIntentForm(context, logger);\n    registerRegenerateContext(context, logger);\n\n    logger.info('‚úÖ Intent commands registered');\n\n    // ========================================\n    // CATEGOR√çA 2: COMANDOS DE NUCLEUS\n    // ========================================\n    registerNucleusCommands(context, logger, managers, providers);\n    logger.info('‚úÖ Nucleus commands registered');\n\n    // ========================================\n    // CATEGOR√çA 3: COMANDOS DE PROFILES\n    // ========================================\n    registerProfileCommands(context, logger, managers);\n    logger.info('‚úÖ Profile commands registered');\n\n    // ========================================\n    // CATEGOR√çA 4: COMANDOS DE GIT\n    // ========================================\n    registerGitCommands(context, logger);\n    logger.info('‚úÖ Git commands registered');\n\n    // ========================================\n    // CATEGOR√çA 5: COMANDOS DE DEBUG\n    // ========================================\n    registerDebugCommands(context, logger);\n    logger.info('‚úÖ Debug commands registered');\n\n    logger.info('‚úÖ All commands registered successfully');\n}"
        },
        {
            "p": "src/initialization/managersInitializer.ts",
            "l": "typescript",
            "h": "a729bdf0",
            "c": "// src/initialization/managersInitializer.ts\nimport * as vscode from 'vscode';\nimport { Logger } from '../utils/logger';\nimport { MetadataManager } from '../core/metadataManager';\nimport { ContextGatherer } from '../core/contextGatherer';\nimport { TokenEstimator } from '../utils/tokenEstimator';\nimport { ChromeProfileManager } from '../core/chromeProfileManager';\nimport { WelcomeView } from '../ui/welcome/welcomeView';\nimport { GitManager } from '../utils/gitManager';\n\nexport interface Managers {\n    logger: Logger;\n    metadataManager: MetadataManager;\n    contextGatherer: ContextGatherer;\n    tokenEstimator: TokenEstimator;\n    chromeProfileManager: ChromeProfileManager;\n    welcomeView: WelcomeView;\n}\n\nexport function initializeManagers(\n    context: vscode.ExtensionContext,\n    logger: Logger\n): Managers {\n    // Inicializar GitManager (singleton global)\n    GitManager.initialize(context);\n\n    // Crear instancias de managers\n    const metadataManager = new MetadataManager(logger);\n    const contextGatherer = new ContextGatherer(logger);\n    const tokenEstimator = new TokenEstimator();\n    const chromeProfileManager = new ChromeProfileManager(context, logger);\n    const welcomeView = new WelcomeView(context);\n\n    logger.info('‚úÖ Managers initialized');\n\n    return {\n        logger,\n        metadataManager,\n        contextGatherer,\n        tokenEstimator,\n        chromeProfileManager,\n        welcomeView\n    };\n}"
        },
        {
            "p": "src/initialization/providersInitializer.ts",
            "l": "typescript",
            "h": "ef21fdc5",
            "c": "// src/initialization/providersInitializer.ts\nimport * as vscode from 'vscode';\nimport { Logger } from '../utils/logger';\nimport { IntentTreeProvider } from '../providers/intentTreeProvider';\nimport { NucleusTreeProvider } from '../providers/nucleusTreeProvider';\nimport { NucleusWelcomeProvider } from '../providers/nucleusWelcomeProvider';\nimport { ProfileTreeProvider } from '../providers/profileTreeProvider';\nimport { Managers } from './managersInitializer';\n\nexport interface Providers {\n    intentTreeProvider: IntentTreeProvider;\n    nucleusTreeProvider: NucleusTreeProvider;\n    nucleusWelcomeProvider: NucleusWelcomeProvider;\n}\n\nexport function initializeProviders(\n    context: vscode.ExtensionContext,\n    workspaceFolder: vscode.WorkspaceFolder,\n    logger: Logger,\n    managers: Managers\n): Providers {\n    // Intent Tree Provider\n    const intentTreeProvider = new IntentTreeProvider(\n        workspaceFolder,\n        logger,\n        managers.metadataManager\n    );\n    vscode.window.registerTreeDataProvider('bloomIntents', intentTreeProvider);\n\n    // Nucleus Tree Provider (Real)\n    const nucleusTreeProvider = new NucleusTreeProvider(\n        workspaceFolder.uri.fsPath,\n        context\n    );\n    vscode.window.registerTreeDataProvider('bloomNucleus', nucleusTreeProvider);\n\n    // Crear TreeView con configuraci√≥n\n    vscode.window.createTreeView('bloomNucleus', {\n        treeDataProvider: nucleusTreeProvider,\n        showCollapseAll: true\n    });\n\n    // Nucleus Welcome Provider (Para primera vez)\n    const nucleusWelcomeProvider = new NucleusWelcomeProvider(context);\n    vscode.window.registerTreeDataProvider('bloomNucleusWelcome', nucleusWelcomeProvider);\n\n    // Profile Tree Provider (Singleton)\n    try {\n        ProfileTreeProvider.initialize(context, logger, managers.chromeProfileManager);\n        logger.info('‚úÖ ProfileTreeProvider initialized');\n    } catch (error: any) {\n        logger.error('‚ùå Error initializing ProfileTreeProvider', error);\n    }\n\n    logger.info('‚úÖ Tree providers registered');\n\n    return {\n        intentTreeProvider,\n        nucleusTreeProvider,\n        nucleusWelcomeProvider\n    };\n}"
        },
        {
            "p": "src/managers/userManager.ts",
            "l": "typescript",
            "h": "2bc91801",
            "c": "// src/managers/userManager.ts\nimport * as vscode from 'vscode';\n\nexport interface BloomUser {\n    githubUsername: string;\n    githubOrg: string;\n    allOrgs: string[];\n    registeredAt: number;\n}\n\nexport class UserManager {\n    private static instance: UserManager;\n    private context: vscode.ExtensionContext;\n\n    private constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n    }\n\n    static init(context: vscode.ExtensionContext): UserManager {\n        if (!UserManager.instance) {\n            UserManager.instance = new UserManager(context);\n        }\n        return UserManager.instance;\n    }\n\n    getUser(): BloomUser | null {\n        const user = this.context.globalState.get<BloomUser>('bloom.user.v3');\n        return user ?? null;\n    }\n\n    async saveUser(data: {\n        githubUsername: string;\n        githubOrg?: string;\n        allOrgs?: string[];\n    }): Promise<void> {\n        const finalUser: BloomUser = {\n            githubUsername: data.githubUsername.trim().replace('@', ''),\n            githubOrg: (data.githubOrg?.trim() || data.githubUsername.trim().replace('@', '')),\n            allOrgs: data.allOrgs || [data.githubUsername.trim().replace('@', '')],\n            registeredAt: Date.now()\n        };\n\n        await this.context.globalState.update('bloom.user.v3', finalUser);\n        await vscode.commands.executeCommand('setContext', 'bloom.isRegistered', true);\n    }\n\n    isRegistered(): boolean {\n        const user = this.getUser();\n        return !!user?.githubUsername && !!user?.allOrgs?.length;\n    }\n\n    async clear(): Promise<void> {\n        await this.context.globalState.update('bloom.user.v3', undefined);\n        await vscode.commands.executeCommand('setContext', 'bloom.isRegistered', false);\n    }\n\n    static async getUserData(): Promise<BloomUser | null> {\n        const context = this.instance?.context;\n        if (!context) return null;\n\n        const user = context.globalState.get<BloomUser>('bloom.user.v3');\n        return user ?? null;\n    }\n\n    // ========================================\n    // LEGACY SUPPORT (para migraci√≥n desde v1)\n    // ========================================\n\n    async migrateFromV1(): Promise<boolean> {\n        // Si ya hay usuario v3, no migrar\n        if (this.getUser()) {\n            return false;\n        }\n\n        // Intentar leer datos v1\n        const email = this.context.globalState.get<string>('bloom.user.email');\n        const name = this.context.globalState.get<string>('bloom.user.name');\n        const registeredAt = this.context.globalState.get<string>('bloom.user.registeredAt');\n\n        if (!email) {\n            return false; // No hay nada que migrar\n        }\n\n        // Convertir a v3 format\n        const username = email.split('@')[0]; // username aproximado\n\n        await this.saveUser({\n            githubUsername: username,\n            githubOrg: username,\n            allOrgs: [username]\n        });\n\n        // Limpiar datos v1\n        await this.context.globalState.update('bloom.user.email', undefined);\n        await this.context.globalState.update('bloom.user.name', undefined);\n        await this.context.globalState.update('bloom.user.registeredAt', undefined);\n        await this.context.globalState.update('bloom.user.acceptedTerms', undefined);\n\n        console.log('[UserManager] Migrated user from v1 to v3');\n        return true;\n    }\n\n    getLegacyUser(): any {\n        return {\n            email: this.context.globalState.get<string>('bloom.user.email'),\n            name: this.context.globalState.get<string>('bloom.user.name'),\n            registeredAt: this.context.globalState.get<string>('bloom.user.registeredAt'),\n            acceptedTerms: this.context.globalState.get<boolean>('bloom.user.acceptedTerms')\n        };\n    }\n}"
        },
        {
            "p": "src/managers/workspaceManager.ts",
            "l": "typescript",
            "h": "be5d7ccb",
            "c": "// src/managers/workspaceManager.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nexport class WorkspaceManager {\n    static async initializeWorkspace(\n        nucleusPath: string,\n        orgName: string\n    ): Promise<string> {\n        try {\n            const nucleusName = path.basename(nucleusPath);\n\n            // Crear carpeta .workspace dentro del Nucleus\n            const workspaceDir = path.join(nucleusPath, '.workspace');\n            if (!fs.existsSync(workspaceDir)) {\n                fs.mkdirSync(workspaceDir, { recursive: true });\n            }\n\n            // Path del archivo workspace (DENTRO del Nucleus)\n            const workspaceFileName = `${orgName}.code-workspace`;\n            const workspaceFilePath = path.join(workspaceDir, workspaceFileName);\n\n            console.log(`[WorkspaceManager] Creating workspace file at: ${workspaceFilePath}`);\n\n            // Configuraci√≥n inicial del workspace\n            const workspaceConfig = {\n                folders: [\n                    {\n                        name: `üè¢ ${nucleusName}`,\n                        path: '..'  // Relativo a .workspace/\n                    }\n                ],\n                settings: {\n                    'bloom.activeNucleus': nucleusName,\n                    'window.title': `${orgName} Workspace`,\n                    'files.exclude': {\n                    }\n                },\n                extensions: {\n                    recommendations: [\n                        'bloom.bloom-btip-plugin'\n                    ]\n                }\n            };\n\n            // Escribir archivo\n            fs.writeFileSync(\n                workspaceFilePath,\n                JSON.stringify(workspaceConfig, null, 2),\n                'utf-8'\n            );\n\n            console.log(`[WorkspaceManager] Workspace file created successfully`);\n            return workspaceFilePath;\n\n        } catch (error: any) {\n            console.error('[WorkspaceManager] Error creating workspace:', error);\n            throw new Error(`Failed to create workspace: ${error.message}`);\n        }\n    }\n\n    static getWorkspaceFilePath(nucleusPath: string, orgName: string): string {\n        const workspaceDir = path.join(nucleusPath, '.workspace');\n        const workspaceFileName = `${orgName}.code-workspace`;\n        return path.join(workspaceDir, workspaceFileName);\n    }\n\n    static hasWorkspaceFile(nucleusPath: string, orgName: string): boolean {\n        const workspaceFilePath = this.getWorkspaceFilePath(nucleusPath, orgName);\n        return fs.existsSync(workspaceFilePath);\n    }\n\n    static async addProjectToWorkspace(\n        nucleusPath: string,\n        orgName: string,\n        projectPath: string,\n        projectName: string,\n        strategy: string\n    ): Promise<void> {\n        try {\n            const workspaceFilePath = this.getWorkspaceFilePath(nucleusPath, orgName);\n\n            // Verificar que el workspace file existe\n            if (!fs.existsSync(workspaceFilePath)) {\n                throw new Error(`Workspace file not found: ${workspaceFilePath}`);\n            }\n\n            // Leer configuraci√≥n actual\n            const currentConfig = JSON.parse(\n                fs.readFileSync(workspaceFilePath, 'utf-8')\n            );\n\n            // Calcular path relativo desde .workspace/ al proyecto\n            const workspaceDir = path.dirname(workspaceFilePath);\n            const relativePath = path.relative(workspaceDir, projectPath);\n\n            // Verificar si ya existe\n            const existingFolder = currentConfig.folders.find(\n                (f: any) => f.path === relativePath\n            );\n\n            if (existingFolder) {\n                console.log(`[WorkspaceManager] Project already in workspace: ${projectName}`);\n                return;\n            }\n\n            // Agregar nuevo proyecto\n            const icon = this.getProjectIcon(strategy);\n            currentConfig.folders.push({\n                name: `${icon} ${projectName}`,\n                path: relativePath\n            });\n\n            // Escribir archivo actualizado\n            fs.writeFileSync(\n                workspaceFilePath,\n                JSON.stringify(currentConfig, null, 2),\n                'utf-8'\n            );\n\n            console.log(`[WorkspaceManager] Project added to workspace: ${projectName}`);\n\n            // Si el workspace actual NO es este archivo, ofrecer abrirlo\n            const currentWorkspace = vscode.workspace.workspaceFile;\n            if (!currentWorkspace || currentWorkspace.fsPath !== workspaceFilePath) {\n                await this.promptToOpenWorkspace(workspaceFilePath, orgName);\n            } else {\n                // Si ya estamos en este workspace, recargar\n                await vscode.commands.executeCommand('workbench.action.reloadWindow');\n            }\n\n        } catch (error: any) {\n            console.error('[WorkspaceManager] Error adding project to workspace:', error);\n            throw error;\n        }\n    }\n\n    static async removeProjectFromWorkspace(\n        nucleusPath: string,\n        orgName: string,\n        projectPath: string\n    ): Promise<void> {\n        try {\n            const workspaceFilePath = this.getWorkspaceFilePath(nucleusPath, orgName);\n\n            if (!fs.existsSync(workspaceFilePath)) {\n                return; // No hay workspace file\n            }\n\n            // Leer configuraci√≥n actual\n            const currentConfig = JSON.parse(\n                fs.readFileSync(workspaceFilePath, 'utf-8')\n            );\n\n            // Calcular path relativo\n            const workspaceDir = path.dirname(workspaceFilePath);\n            const relativePath = path.relative(workspaceDir, projectPath);\n\n            // Filtrar el proyecto\n            currentConfig.folders = currentConfig.folders.filter(\n                (f: any) => f.path !== relativePath\n            );\n\n            // Escribir archivo actualizado\n            fs.writeFileSync(\n                workspaceFilePath,\n                JSON.stringify(currentConfig, null, 2),\n                'utf-8'\n            );\n\n            console.log(`[WorkspaceManager] Project removed from workspace`);\n\n        } catch (error: any) {\n            console.error('[WorkspaceManager] Error removing project:', error);\n            throw error;\n        }\n    }\n\n    private static async promptToOpenWorkspace(\n        workspaceFilePath: string,\n        orgName: string\n    ): Promise<void> {\n        const action = await vscode.window.showInformationMessage(\n            `‚úÖ Proyecto agregado al workspace de ${orgName}`,\n            {\n                modal: false,\n                detail: 'El workspace se actualiz√≥. ¬øQuer√©s abrirlo ahora?'\n            },\n            'Abrir Workspace',\n            'M√°s Tarde'\n        );\n\n        if (action === 'Abrir Workspace') {\n            const workspaceUri = vscode.Uri.file(workspaceFilePath);\n            await vscode.commands.executeCommand('vscode.openFolder', workspaceUri, {\n                forceNewWindow: false\n            });\n        }\n    }\n\n    static async syncWorkspaceFile(\n        nucleusPath: string,\n        orgName: string\n    ): Promise<void> {\n        try {\n            const workspaceFilePath = this.getWorkspaceFilePath(nucleusPath, orgName);\n\n            if (!fs.existsSync(workspaceFilePath)) {\n                return; // No hay nada que sincronizar\n            }\n\n            // Obtener folders actuales de VSCode\n            const currentFolders = vscode.workspace.workspaceFolders || [];\n\n            if (currentFolders.length === 0) {\n                return;\n            }\n\n            // Leer configuraci√≥n del archivo\n            const fileConfig = JSON.parse(\n                fs.readFileSync(workspaceFilePath, 'utf-8')\n            );\n\n            // Actualizar folders en la configuraci√≥n\n            const workspaceDir = path.dirname(workspaceFilePath);\n            fileConfig.folders = currentFolders.map(folder => {\n                const relativePath = path.relative(workspaceDir, folder.uri.fsPath);\n                return {\n                    name: folder.name,\n                    path: relativePath\n                };\n            });\n\n            // Escribir archivo actualizado\n            fs.writeFileSync(\n                workspaceFilePath,\n                JSON.stringify(fileConfig, null, 2),\n                'utf-8'\n            );\n\n            console.log(`[WorkspaceManager] Workspace file synced`);\n\n        } catch (error: any) {\n            console.error('[WorkspaceManager] Error syncing workspace:', error);\n        }\n    }\n\n    static isMultiRootWorkspace(): boolean {\n        return (vscode.workspace.workspaceFolders?.length || 0) > 1;\n    }\n\n    static getCurrentNucleusPath(): string | null {\n        const folders = vscode.workspace.workspaceFolders;\n        if (!folders) return null;\n\n        // Buscar la carpeta que contenga nucleus-config.json\n        for (const folder of folders) {\n            const configPath = path.join(\n                folder.uri.fsPath,\n                '.bloom',\n                'core',\n                'nucleus-config.json'\n            );\n            if (fs.existsSync(configPath)) {\n                return folder.uri.fsPath;\n            }\n        }\n\n        return null;\n    }\n\n    static getProjectIcon(strategy: string): string {\n        const icons: Record<string, string> = {\n            'nucleus': 'üè¢',\n            'android': 'ü§ñ',\n            'ios': 'üçé',\n            'react-web': '‚öõÔ∏è',\n            'web': 'üåê',\n            'node': '‚öôÔ∏è',\n            'python-flask': 'üêç',\n            'generic': 'üì¶'\n        };\n\n        return icons[strategy] || 'üì¶';\n    }\n\n    static async openWorkspace(workspaceFilePath: string): Promise<void> {\n        const workspaceUri = vscode.Uri.file(workspaceFilePath);\n        await vscode.commands.executeCommand('vscode.openFolder', workspaceUri, {\n            forceNewWindow: false\n        });\n    }\n\n    static async createWorkspaceGitignore(nucleusPath: string): Promise<void> {\n        const workspaceDir = path.join(nucleusPath, '.workspace');\n        const gitignorePath = path.join(workspaceDir, '.gitignore');\n\n        if (fs.existsSync(gitignorePath)) {\n            return; // Ya existe\n        }\n\n        const gitignoreContent = `# Ignorar workspace files (opcional)\n# Descomentar si NO quer√©s versionar la configuraci√≥n del workspace\n# *.code-workspace\n\n# Pero S√ç versionar templates\n!template.code-workspace\n`;\n\n        fs.writeFileSync(gitignorePath, gitignoreContent, 'utf-8');\n        console.log('[WorkspaceManager] .gitignore created in .workspace/');\n    }\n}"
        },
        {
            "p": "src/providers/intentTreeProvider.ts",
            "l": "typescript",
            "h": "33b61fad",
            "c": "import * as vscode from 'vscode';\nimport * as fs from 'fs'; // Agregado para fs.existsSync\nimport { Intent, IntentMetadata, IntentStatus } from '../models/intent';\nimport { Logger } from '../utils/logger';\nimport { MetadataManager } from '../core/metadataManager';\nimport { joinPath } from '../utils/uriHelper';\n\nexport class IntentTreeProvider implements vscode.TreeDataProvider<IntentTreeItem | IntentGroupItem> {\n    private _onDidChangeTreeData = new vscode.EventEmitter<IntentTreeItem | IntentGroupItem | undefined>();\n    readonly onDidChangeTreeData = this._onDidChangeTreeData.event;\n\n    constructor(\n        private workspaceFolder: vscode.WorkspaceFolder,\n        private logger: Logger,\n        private metadataManager: MetadataManager\n    ) {}\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire(undefined);\n    }\n\n     getTreeItem(element: IntentTreeItem | IntentGroupItem): vscode.TreeItem {\n        return element;\n    }\n\n    async getChildren(element?: IntentTreeItem | IntentGroupItem): Promise<Array<IntentTreeItem | IntentGroupItem>> {\n        if (!element) {\n            return [\n                new IntentGroupItem('in-progress', 'In Progress', this.workspaceFolder),\n                new IntentGroupItem('completed', 'Completed', this.workspaceFolder),\n                new IntentGroupItem('archived', 'Archived', this.workspaceFolder)\n            ];\n        }\n\n        if (element instanceof IntentGroupItem) {\n            const intents = await this.loadIntentsByStatus(element.status);\n            return intents.map(intent => new IntentTreeItem(intent));\n        }\n\n        return [];\n    }\n\n    private async loadIntentsByStatus(status: IntentStatus): Promise<Intent[]> {\n        const intentsDir = joinPath(\n            this.workspaceFolder.uri,\n            '.bloom',\n            'intents'\n        );\n\n        // Nuevo: Check si el directorio existe para evitar ENOENT\n        const intentsPath = intentsDir.fsPath;\n        if (!fs.existsSync(intentsPath)) {\n            this.logger.info(`Intents directory not found: ${intentsPath} - Returning empty list.`);\n            return [];\n        }\n\n        try {\n            const entries = await vscode.workspace.fs.readDirectory(intentsDir);\n            const intents: Intent[] = [];\n\n            for (const [name, type] of entries) {\n                if (type === vscode.FileType.Directory) {\n                    const intentFolder = joinPath(intentsDir, name);\n                    const metadata = await this.metadataManager.read(intentFolder);\n\n                    if (metadata && metadata.status === status) {\n                        intents.push({ metadata, folderUri: intentFolder });\n                    }\n                }\n            }\n\n            return intents.sort(\n                (a, b) => new Date(b.metadata.updated).getTime() - new Date(a.metadata.updated).getTime()\n            );\n        } catch (error) {\n            this.logger.error('Error al cargar intents', error as Error);\n            return [];\n        }\n    }\n\n    // Nuevo m√©todo para nesting en Nucleus\n    public async getIntents(): Promise<IntentTreeItem[]> {\n        const allIntents: Intent[] = [];\n        const statuses: IntentStatus[] = ['in-progress', 'completed', 'archived'];\n        for (const status of statuses) {\n            const intents = await this.loadIntentsByStatus(status);\n            allIntents.push(...intents);\n        }\n        return allIntents.map(intent => new IntentTreeItem(intent));\n    }\n}\n\nexport class IntentGroupItem extends vscode.TreeItem {\n    constructor(\n        public readonly status: IntentStatus,\n        label: string,\n        private workspaceFolder: vscode.WorkspaceFolder\n    ) {\n        super(label, vscode.TreeItemCollapsibleState.Expanded);\n        this.contextValue = 'intentGroup';\n        this.iconPath = vscode.ThemeIcon.Folder;\n    }\n}\n\nexport class IntentTreeItem extends vscode.TreeItem {\n    constructor(public readonly intent: Intent) {\n        super(\n            intent.metadata.displayName || intent.metadata.name,\n            vscode.TreeItemCollapsibleState.None\n        );\n\n        this.contextValue = 'intent';\n        this.tooltip = this.buildTooltip();\n        this.description = `(${intent.metadata.files.filesCount} archivos)`;\n        this.iconPath = vscode.ThemeIcon.File;\n\n        this.command = {\n            command: 'bloom.openIntent',\n            title: 'Open Intent',\n            arguments: [this]\n        };\n    }\n\n    private buildTooltip(): string {\n        const meta = this.intent.metadata;\n        return `${meta.displayName || meta.name}\\nArchivos: ${meta.files.filesCount}\\nCreado: ${new Date(meta.created).toLocaleDateString()}\\nTags: ${meta.tags?.join(', ') || 'ninguno'}`;\n    }\n}"
        },
        {
            "p": "src/providers/nucleusTreeProvider.ts",
            "l": "typescript",
            "h": "b10a7807",
            "c": "// src/providers/nucleusTreeProvider.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { NucleusConfig, LinkedProject, loadNucleusConfig } from '../models/bloomConfig';\nimport { Logger } from '../utils/logger';\nimport { UserManager } from '../managers/userManager';\nimport { WorkspaceManager } from '../managers/workspaceManager';\n\nexport class NucleusTreeProvider implements vscode.TreeDataProvider<NucleusTreeItem> {\n    private _onDidChangeTreeData = new vscode.EventEmitter<NucleusTreeItem | undefined>();\n    readonly onDidChangeTreeData = this._onDidChangeTreeData.event;\n\n    private configs: Map<string, NucleusConfig> = new Map();\n    private logger = new Logger();\n\n    constructor(\n        private workspaceRoot: string | undefined,\n        private context: vscode.ExtensionContext\n    ) {\n        // Refresh autom√°tico cuando cambia la configuraci√≥n\n        vscode.workspace.onDidChangeConfiguration(() => this.refresh());\n\n        this.refresh();\n    }\n\n    refresh(): void {\n        this.detectAllNucleus();\n        this._onDidChangeTreeData.fire(undefined);\n    }\n\n    private detectAllNucleus(): void {\n        this.configs.clear();\n        const user = UserManager.init(this.context).getUser();\n        if (!user) return;\n\n        const orgs = user.allOrgs || [user.githubUsername];\n\n        for (const org of orgs) {\n            const config = this.detectNucleusForOrg(org);\n            if (config) {\n                this.configs.set(org, config);\n            }\n        }\n    }\n\n    private detectNucleusForOrg(org: string): NucleusConfig | null {\n        if (!this.workspaceRoot) return null;\n\n        // Caso 1: Workspace actual ES un Nucleus\n        const bloomPath = path.join(this.workspaceRoot, '.bloom');\n        const configPath = path.join(bloomPath, 'core', 'nucleus-config.json');\n\n        if (fs.existsSync(configPath)) {\n            const config = loadNucleusConfig(bloomPath);\n            if (config?.organization?.name === org) {\n                return config;\n            }\n        }\n\n        // Caso 2: Workspace tiene link a Nucleus\n        const linkPath = path.join(bloomPath, 'nucleus.json');\n        if (fs.existsSync(linkPath)) {\n            try {\n                const link = JSON.parse(fs.readFileSync(linkPath, 'utf-8'));\n                if (link.organizationName === org && link.nucleusPath) {\n                    const fullPath = path.resolve(this.workspaceRoot, link.nucleusPath);\n                    if (fs.existsSync(fullPath)) {\n                        return loadNucleusConfig(path.join(fullPath, '.bloom'));\n                    }\n                }\n            } catch {}\n        }\n\n        // Caso 3: Buscar en parent directory\n        const parentDir = path.dirname(this.workspaceRoot);\n        const nucleusName = `nucleus-${org}`;\n        const nucleusPath = path.join(parentDir, nucleusName);\n\n        if (fs.existsSync(nucleusPath)) {\n            const nucleusBloomPath = path.join(nucleusPath, '.bloom');\n            if (fs.existsSync(nucleusBloomPath)) {\n                return loadNucleusConfig(nucleusBloomPath);\n            }\n        }\n\n        return null;\n    }\n\n    // Nueva funci√≥n para unlink Nucleus\n    async unlinkNucleus(org: string): Promise<void> {\n        const confirm = await vscode.window.showWarningMessage(\n            `‚õìÔ∏è‚Äçüí• Desvincular Nucleus de ${org}\\n\\nEl repositorio local y remoto NO se borrar√°n.\\nSolo se quitar√° del plugin.`,\n            { modal: true },\n            'Desvincular'\n        );\n\n        if (confirm !== 'Desvincular') return;\n\n        const userManager = UserManager.init(this.context);\n        const userData = userManager.getUser();\n        if (!userData) return;\n\n        // Remover org de allOrgs\n        userData.allOrgs = (userData.allOrgs || []).filter(o => o !== org);\n        userData.githubOrg = userData.allOrgs[0] || userData.githubUsername;\n\n        await userManager.saveUser(userData);\n        await vscode.commands.executeCommand('setContext', 'bloom.isRegistered', !!userData.githubOrg);\n\n        // Cerrar folders relacionadas con este Nucleus\n        const wsFolders = vscode.workspace.workspaceFolders || [];\n        const nucleusPath = this.findNucleusPath(org);\n\n        if (nucleusPath) {\n            // Encontrar √≠ndices de folders a remover\n            const indicesToRemove: number[] = [];\n            wsFolders.forEach((folder, idx) => {\n                if (folder.uri.fsPath.includes(`nucleus-${org}`) ||\n                    folder.uri.fsPath.startsWith(nucleusPath)) {\n                    indicesToRemove.push(idx);\n                }\n            });\n\n            // Remover folders en orden inverso para mantener √≠ndices v√°lidos\n            for (let i = indicesToRemove.length - 1; i >= 0; i--) {\n                vscode.workspace.updateWorkspaceFolders(indicesToRemove[i], 1);\n            }\n        }\n\n        this.refresh();\n        vscode.window.showInformationMessage(`‚úÖ Nucleus ${org} desvinculado correctamente`);\n    }\n\n    getTreeItem(element: NucleusTreeItem): vscode.TreeItem {\n        return element;\n    }\n\n    async getChildren(element?: NucleusTreeItem): Promise<NucleusTreeItem[]> {\n        console.log('[NucleusTree] getChildren called, element:', element?.type);\n\n        if (!element) {\n            const items: NucleusTreeItem[] = [];\n\n            console.log('[NucleusTree] Configs detected:', this.configs.size);\n\n            // Mostrar organizaciones con Nucleus\n            for (const [org, config] of this.configs.entries()) {\n                console.log('[NucleusTree] Processing org:', org, 'projects:', config.projects.length);\n\n                // Encontrar el path del Nucleus\n                const nucleusPath = this.findNucleusPath(org);\n\n                console.log('[NucleusTree] Nucleus path for', org, ':', nucleusPath);\n\n                const orgItem = new NucleusTreeItem(\n                    `${org} (${config.projects.length} proyecto${config.projects.length !== 1 ? 's' : ''})`,\n                    vscode.TreeItemCollapsibleState.Expanded,\n                    'org',\n                    { orgName: org, nucleusPath: nucleusPath, config: config }\n                );\n\n                // IMPORTANTE: Agregar tooltip para que el usuario sepa que puede agregar\n                orgItem.tooltip = `Click derecho o en el √≠cono + para agregar proyectos`;\n\n                console.log('[NucleusTree] orgItem contextValue:', orgItem.contextValue);\n\n                items.push(orgItem);\n            }\n\n            // Solo mostrar si no hay Nucleus detectados\n            if (items.length === 0) {\n                console.log('[NucleusTree] No configs found, showing info message');\n                items.push(new NucleusTreeItem(\n                    'No hay Nucleus en este workspace',\n                    vscode.TreeItemCollapsibleState.None,\n                    'info'\n                ));\n            }\n\n            console.log('[NucleusTree] Returning', items.length, 'items');\n            return items;\n        }\n\n        if (element.type === 'org') {\n            const org = element.data.orgName;\n            const config = this.configs.get(org);\n            if (!config?.projects) return [];\n\n            return config.projects.map(p =>\n                new NucleusTreeItem(\n                    `${this.getProjectIcon(p.strategy)} ${p.displayName || p.name}`,\n                    vscode.TreeItemCollapsibleState.None,\n                    'project',\n                    p,\n                    {\n                        command: 'bloom.openNucleusProject',\n                        title: 'Abrir proyecto',\n                        arguments: [p]\n                    }\n                )\n            );\n        }\n\n        return [];\n    }\n\n    private findNucleusPath(org: string): string | undefined {\n        if (!this.workspaceRoot) return undefined;\n\n        // Intentar workspace actual\n        const localBloom = path.join(this.workspaceRoot, '.bloom', 'core', 'nucleus-config.json');\n        if (fs.existsSync(localBloom)) {\n            return this.workspaceRoot;\n        }\n\n        // Intentar parent directory\n        const parentDir = path.dirname(this.workspaceRoot);\n        const nucleusPath = path.join(parentDir, `nucleus-${org}`);\n        if (fs.existsSync(nucleusPath)) {\n            return nucleusPath;\n        }\n\n        return undefined;\n    }\n\n    private getProjectIcon(strategy: string): string {\n        const icons: Record<string, string> = {\n            'android': 'üì±',\n            'ios': 'üçé',\n            'react-web': 'üåê',\n            'web': 'üåê',\n            'node': '‚öôÔ∏è',\n            'python-flask': 'üêç',\n            'php-laravel': 'üêò',\n            'generic': 'üì¶'\n        };\n        return icons[strategy] || 'üì¶';\n    }\n\n    // M√©todo p√∫blico para obtener nucleusPath\n    public getNucleusPath(org: string): string | undefined {\n        return this.findNucleusPath(org);\n    }\n}\n\nclass NucleusTreeItem extends vscode.TreeItem {\n    constructor(\n        label: string,\n        collapsibleState: vscode.TreeItemCollapsibleState,\n        public readonly type: 'org' | 'project' | 'info',\n        public readonly data?: any,\n        command?: vscode.Command\n    ) {\n        super(label, collapsibleState);\n        this.command = command;\n\n        switch (type) {\n            case 'org':\n                this.iconPath = new vscode.ThemeIcon('organization');\n                this.contextValue = 'nucleusOrg';\n                break;\n            case 'project':\n                this.iconPath = new vscode.ThemeIcon('folder');\n                this.contextValue = 'nucleusProject';\n                this.tooltip = `${data.name} - ${data.strategy}`;\n                break;\n            case 'info':\n                this.iconPath = new vscode.ThemeIcon('info');\n                break;\n        }\n    }\n}\n\nexport async function openNucleusProject(project: LinkedProject): Promise<void> {\n    try {\n        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n        if (!workspaceRoot) {\n            vscode.window.showErrorMessage('No workspace folder found');\n            return;\n        }\n\n        // Intentar encontrar el proyecto\n        let projectPath: string | null = null;\n\n        // 1. Relativo al workspace actual\n        const relativePath = path.join(workspaceRoot, project.localPath);\n        if (fs.existsSync(relativePath)) {\n            projectPath = relativePath;\n        } else {\n            // 2. Relativo al parent directory\n            const parentDir = path.dirname(workspaceRoot);\n            const parentRelativePath = path.join(parentDir, project.localPath);\n            if (fs.existsSync(parentRelativePath)) {\n                projectPath = parentRelativePath;\n            }\n        }\n\n        if (!projectPath) {\n            const browse = await vscode.window.showWarningMessage(\n                `No se encontr√≥ el proyecto en: ${project.localPath}`,\n                'Buscar Manualmente',\n                'Cancelar'\n            );\n\n            if (browse === 'Buscar Manualmente') {\n                const selected = await vscode.window.showOpenDialog({\n                    canSelectFiles: false,\n                    canSelectFolders: true,\n                    canSelectMany: false,\n                    openLabel: `Seleccionar carpeta de ${project.name}`,\n                    title: `Localizar ${project.displayName}`\n                });\n\n                if (selected && selected.length > 0) {\n                    projectPath = selected[0].fsPath;\n                }\n            }\n\n            if (!projectPath) return;\n        }\n\n        // Encontrar el Nucleus path y org desde nucleus.json del proyecto\n        let nucleusPath: string | undefined;\n        let orgName: string | undefined;\n\n        const nucleusLinkPath = path.join(projectPath, '.bloom', 'nucleus.json');\n        if (fs.existsSync(nucleusLinkPath)) {\n            try {\n                const linkData = JSON.parse(fs.readFileSync(nucleusLinkPath, 'utf-8'));\n                orgName = linkData.organizationName;\n\n                // Resolver path del Nucleus\n                if (linkData.nucleusPath) {\n                    nucleusPath = path.resolve(projectPath, linkData.nucleusPath);\n                }\n            } catch (error) {\n                console.error('Error reading nucleus.json:', error);\n            }\n        }\n\n        // Si no se pudo obtener del nucleus.json, buscar en parent\n        if (!nucleusPath || !orgName) {\n            const parentDir = path.dirname(projectPath);\n            const nucleusDirs = fs.readdirSync(parentDir).filter(d => d.startsWith('nucleus-'));\n\n            if (nucleusDirs.length > 0) {\n                nucleusPath = path.join(parentDir, nucleusDirs[0]);\n                orgName = nucleusDirs[0].replace('nucleus-', '');\n            }\n        }\n\n        // Si a√∫n no tenemos nucleus info, usar valores por defecto\n        if (!nucleusPath || !orgName) {\n            vscode.window.showWarningMessage('No se pudo determinar el Nucleus asociado. Agregando solo al workspace.');\n\n            // Agregar solo la carpeta al workspace\n            const workspaceFolders = vscode.workspace.workspaceFolders || [];\n            const folderExists = workspaceFolders.some(f => f.uri.fsPath === projectPath);\n\n            if (!folderExists) {\n                await vscode.workspace.updateWorkspaceFolders(\n                    workspaceFolders.length,\n                    0,\n                    { uri: vscode.Uri.file(projectPath), name: project.displayName }\n                );\n            }\n\n            return;\n        }\n\n        // Agregar al workspace usando WorkspaceManager\n        await WorkspaceManager.addProjectToWorkspace(\n            nucleusPath,\n            orgName,\n            projectPath,\n            project.displayName,\n            project.strategy\n        );\n\n    } catch (error: any) {\n        vscode.window.showErrorMessage(`Error abriendo proyecto: ${error.message}`);\n    }\n}"
        },
        {
            "p": "src/utils/gitManager.ts",
            "l": "typescript",
            "h": "fd08118e",
            "c": "// src/utils/gitManager.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { GitExecutor } from './gitExecutor';\nimport { Logger } from './logger';\n\nexport interface GitChange {\n    file: string;\n    status: 'added' | 'modified' | 'deleted';\n}\n\nexport interface PendingCommit {\n    repoPath: string;\n    repoName: string;\n    message: string;\n    changes: GitChange[];\n    timestamp: number;\n}\n\nexport class GitManager {\n    private static pendingCommits: PendingCommit[] = [];\n    private static statusBarItem: vscode.StatusBarItem;\n    private static logger: Logger;\n\n    static initialize(context: vscode.ExtensionContext) {\n        this.statusBarItem = vscode.window.createStatusBarItem(\n            vscode.StatusBarAlignment.Left,\n            100\n        );\n        this.statusBarItem.command = 'bloom.reviewPendingCommits';\n        context.subscriptions.push(this.statusBarItem);\n        this.updateStatusBar();\n    }\n\n    static async queueCommit(\n        repoPath: string,\n        message: string,\n        files?: string[]\n    ): Promise<void> {\n        const repoName = path.basename(repoPath);\n\n        // Detectar cambios\n        const changes = await this.getChanges(repoPath, files);\n\n        if (changes.length === 0) {\n            return; // No hay nada que commitear\n        }\n\n        // Agregar a la cola\n        this.pendingCommits.push({\n            repoPath,\n            repoName,\n            message,\n            changes,\n            timestamp: Date.now()\n        });\n\n        this.updateStatusBar();\n        this.showNotification(repoName, changes.length);\n    }\n\n    private static async getChanges(\n        repoPath: string,\n        files?: string[]\n    ): Promise<GitChange[]> {\n        try {\n            const { stdout } = await GitExecutor.exec('status --porcelain', {\n                cwd: repoPath\n            });\n\n            if (!stdout.trim()) {\n                return [];\n            }\n\n            const lines = stdout.trim().split('\\n');\n            const changes: GitChange[] = [];\n\n            for (const line of lines) {\n                const status = line.substring(0, 2).trim();\n                const file = line.substring(3);\n\n                // Si se especificaron archivos, filtrar\n                if (files && files.length > 0) {\n                    if (!files.some(f => file.includes(f))) {\n                        continue;\n                    }\n                }\n\n                let changeStatus: 'added' | 'modified' | 'deleted';\n                if (status.includes('A')) changeStatus = 'added';\n                else if (status.includes('D')) changeStatus = 'deleted';\n                else changeStatus = 'modified';\n\n                changes.push({ file, status: changeStatus });\n            }\n\n            return changes;\n        } catch (error) {\n            console.error('[GitManager] Error getting git changes:', error);\n            return [];\n        }\n    }\n\n    private static showNotification(repoName: string, changeCount: number) {\n        const message = `üíæ ${changeCount} cambio(s) guardado(s) en ${repoName}`;\n\n        vscode.window.showInformationMessage(\n            message,\n            'Ver Cambios',\n            'M√°s Tarde'\n        ).then(selection => {\n            if (selection === 'Ver Cambios') {\n                vscode.commands.executeCommand('bloom.reviewPendingCommits');\n            }\n        });\n    }\n\n    private static updateStatusBar() {\n        if (this.pendingCommits.length === 0) {\n            this.statusBarItem.hide();\n            return;\n        }\n\n        const total = this.pendingCommits.reduce((sum, c) => sum + c.changes.length, 0);\n        const repos = [...new Set(this.pendingCommits.map(c => c.repoName))].length;\n\n        this.statusBarItem.text = `$(git-commit) ${total} cambios en ${repos} repo(s)`;\n        this.statusBarItem.tooltip = 'Click para revisar y commitear';\n        this.statusBarItem.show();\n    }\n\n    static async reviewAndCommit(): Promise<void> {\n        if (this.pendingCommits.length === 0) {\n            vscode.window.showInformationMessage('No hay cambios pendientes');\n            return;\n        }\n\n        // Crear panel webview\n        const panel = vscode.window.createWebviewPanel(\n            'bloomGitReview',\n            'Revisar Commits Pendientes',\n            vscode.ViewColumn.One,\n            { enableScripts: true }\n        );\n\n        panel.webview.html = this.getReviewHtml();\n\n        // Enviar datos\n        panel.webview.postMessage({\n            command: 'loadCommits',\n            commits: this.pendingCommits\n        });\n\n        // Escuchar acciones\n        panel.webview.onDidReceiveMessage(async (message) => {\n            switch (message.command) {\n                case 'editMessage':\n                    await this.editCommitMessage(message.index, message.newMessage);\n                    panel.webview.postMessage({\n                        command: 'loadCommits',\n                        commits: this.pendingCommits\n                    });\n                    break;\n\n                case 'commitAndPush':\n                    await this.executeCommit(message.index, true);\n                    this.pendingCommits.splice(message.index, 1);\n\n                    if (this.pendingCommits.length === 0) {\n                        panel.dispose();\n                    } else {\n                        panel.webview.postMessage({\n                            command: 'loadCommits',\n                            commits: this.pendingCommits\n                        });\n                    }\n                    this.updateStatusBar();\n                    break;\n\n                case 'commitOnly':\n                    await this.executeCommit(message.index, false);\n                    this.pendingCommits.splice(message.index, 1);\n\n                    if (this.pendingCommits.length === 0) {\n                        panel.dispose();\n                    } else {\n                        panel.webview.postMessage({\n                            command: 'loadCommits',\n                            commits: this.pendingCommits\n                        });\n                    }\n                    this.updateStatusBar();\n                    break;\n\n                case 'discard':\n                    this.pendingCommits.splice(message.index, 1);\n\n                    if (this.pendingCommits.length === 0) {\n                        panel.dispose();\n                    } else {\n                        panel.webview.postMessage({\n                            command: 'loadCommits',\n                            commits: this.pendingCommits\n                        });\n                    }\n                    this.updateStatusBar();\n                    break;\n\n                case 'commitAll':\n                    await this.commitAll(message.withPush);\n                    panel.dispose();\n                    break;\n            }\n        });\n    }\n\n    private static async editCommitMessage(index: number, newMessage: string) {\n        if (this.pendingCommits[index]) {\n            this.pendingCommits[index].message = newMessage;\n        }\n    }\n\n    private static async executeCommit(index: number, withPush: boolean): Promise<void> {\n        const commit = this.pendingCommits[index];\n\n        try {\n            // Stage cambios\n            await GitExecutor.exec('add .', { cwd: commit.repoPath });\n\n            // Commit\n            const escapedMessage = commit.message.replace(/\"/g, '\\\\\"');\n            await GitExecutor.exec(`commit -m \"${escapedMessage}\"`, {\n                cwd: commit.repoPath\n            });\n\n            // Push si se solicita\n            if (withPush) {\n                await GitExecutor.exec('push', { cwd: commit.repoPath });\n                vscode.window.showInformationMessage(\n                    `‚úÖ Commit + Push exitoso en ${commit.repoName}`\n                );\n            } else {\n                vscode.window.showInformationMessage(\n                    `‚úÖ Commit exitoso en ${commit.repoName} (sin push)`\n                );\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(\n                `Error en ${commit.repoName}: ${error.message}`\n            );\n        }\n    }\n\n    private static async commitAll(withPush: boolean): Promise<void> {\n        let successful = 0;\n        let failed = 0;\n\n        for (const commit of this.pendingCommits) {\n            try {\n                await GitExecutor.exec('add .', { cwd: commit.repoPath });\n                const escapedMessage = commit.message.replace(/\"/g, '\\\\\"');\n                await GitExecutor.exec(`commit -m \"${escapedMessage}\"`, {\n                    cwd: commit.repoPath\n                });\n\n                if (withPush) {\n                    await GitExecutor.exec('push', { cwd: commit.repoPath });\n                }\n\n                successful++;\n            } catch (error) {\n                failed++;\n            }\n        }\n\n        this.pendingCommits = [];\n        this.updateStatusBar();\n\n        const action = withPush ? 'Commit + Push' : 'Commit';\n        vscode.window.showInformationMessage(\n            `${action}: ${successful} exitosos, ${failed} fallidos`\n        );\n    }\n\n    private static getReviewHtml(): string {\n        return `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        body {\n            font-family: var(--vscode-font-family);\n            color: var(--vscode-foreground);\n            background: var(--vscode-editor-background);\n            padding: 20px;\n        }\n        h1 { margin-bottom: 20px; }\n        .commit-card {\n            background: var(--vscode-input-background);\n            border: 1px solid var(--vscode-input-border);\n            border-radius: 4px;\n            padding: 16px;\n            margin-bottom: 16px;\n        }\n        .commit-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 12px;\n        }\n        .repo-name {\n            font-weight: 600;\n            font-size: 16px;\n        }\n        .timestamp {\n            font-size: 12px;\n            color: var(--vscode-descriptionForeground);\n        }\n        .commit-message {\n            width: 100%;\n            padding: 8px;\n            margin-bottom: 12px;\n            background: var(--vscode-editor-background);\n            border: 1px solid var(--vscode-input-border);\n            color: var(--vscode-input-foreground);\n            border-radius: 4px;\n            font-family: monospace;\n        }\n        .changes-list {\n            margin-bottom: 12px;\n            padding: 8px;\n            background: rgba(0,0,0,0.2);\n            border-radius: 4px;\n            max-height: 150px;\n            overflow-y: auto;\n        }\n        .change-item {\n            font-family: monospace;\n            font-size: 12px;\n            padding: 2px 0;\n        }\n        .added { color: #4ec9b0; }\n        .modified { color: #ce9178; }\n        .deleted { color: #f48771; }\n        .actions {\n            display: flex;\n            gap: 8px;\n        }\n        button {\n            padding: 8px 16px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-weight: 600;\n        }\n        .btn-primary {\n            background: var(--vscode-button-background);\n            color: var(--vscode-button-foreground);\n        }\n        .btn-secondary {\n            background: var(--vscode-button-secondaryBackground);\n            color: var(--vscode-button-secondaryForeground);\n        }\n        .btn-danger {\n            background: transparent;\n            color: var(--vscode-errorForeground);\n            border: 1px solid var(--vscode-errorForeground);\n        }\n        .bulk-actions {\n            position: sticky;\n            top: 0;\n            background: var(--vscode-editor-background);\n            padding: 16px 0;\n            border-bottom: 1px solid var(--vscode-panel-border);\n            margin-bottom: 20px;\n            display: flex;\n            gap: 8px;\n        }\n    </style>\n</head>\n<body>\n    <h1>üìã Revisar Commits Pendientes</h1>\n\n    <div class=\"bulk-actions\">\n        <button class=\"btn-primary\" onclick=\"commitAll(true)\">‚úÖ Commit + Push Todos</button>\n        <button class=\"btn-secondary\" onclick=\"commitAll(false)\">üíæ Commit Todos (sin push)</button>\n    </div>\n\n    <div id=\"commits\"></div>\n\n    <script>\n        const vscode = acquireVsCodeApi();\n\n        window.addEventListener('message', e => {\n            if (e.data.command === 'loadCommits') {\n                renderCommits(e.data.commits);\n            }\n        });\n\n        function renderCommits(commits) {\n            const container = document.getElementById('commits');\n            container.innerHTML = commits.map((commit, i) => \\`\n                <div class=\"commit-card\">\n                    <div class=\"commit-header\">\n                        <span class=\"repo-name\">üì¶ \\${commit.repoName}</span>\n                        <span class=\"timestamp\">\\${new Date(commit.timestamp).toLocaleString()}</span>\n                    </div>\n\n                    <textarea class=\"commit-message\" id=\"msg-\\${i}\">\\${commit.message}</textarea>\n\n                    <div class=\"changes-list\">\n                        \\${commit.changes.map(c => \\`\n                            <div class=\"change-item \\${c.status}\">\n                                \\${c.status === 'added' ? '+' : c.status === 'deleted' ? '-' : 'M'} \\${c.file}\n                            </div>\n                        \\`).join('')}\n                    </div>\n\n                    <div class=\"actions\">\n                        <button class=\"btn-primary\" onclick=\"commitAndPush(\\${i})\">\n                            ‚úÖ Commit + Push\n                        </button>\n                        <button class=\"btn-secondary\" onclick=\"commitOnly(\\${i})\">\n                            üíæ Solo Commit\n                        </button>\n                        <button class=\"btn-secondary\" onclick=\"editMessage(\\${i})\">\n                            ‚úèÔ∏è Editar\n                        </button>\n                        <button class=\"btn-danger\" onclick=\"discard(\\${i})\">\n                            üóëÔ∏è Descartar\n                        </button>\n                    </div>\n                </div>\n            \\`).join('');\n        }\n\n        function editMessage(index) {\n            const newMessage = document.getElementById('msg-' + index).value;\n            vscode.postMessage({\n                command: 'editMessage',\n                index: index,\n                newMessage: newMessage\n            });\n        }\n\n        function commitAndPush(index) {\n            vscode.postMessage({\n                command: 'commitAndPush',\n                index: index\n            });\n        }\n\n        function commitOnly(index) {\n            vscode.postMessage({\n                command: 'commitOnly',\n                index: index\n            });\n        }\n\n        function discard(index) {\n            if (confirm('¬øDescartar estos cambios?')) {\n                vscode.postMessage({\n                    command: 'discard',\n                    index: index\n                });\n            }\n        }\n\n        function commitAll(withPush) {\n            vscode.postMessage({\n                command: 'commitAll',\n                withPush: withPush\n            });\n        }\n    </script>\n</body>\n</html>\n        `;\n    }\n\n    static async stageAndOpenSCM(\n        repoPath: string,\n        files?: string[],\n        commitMessage?: string\n    ): Promise<void> {\n        try {\n            const repoName = path.basename(repoPath);\n\n            console.log(`[GitManager] stageAndOpenSCM called:`, {\n                repoPath,\n                filesCount: files?.length || 'all',\n                hasMessage: !!commitMessage\n            });\n\n            // 1. Verificar que es un repo git v√°lido\n            const isRepo = await GitExecutor.isGitRepository(repoPath);\n            if (!isRepo) {\n                throw new Error(`Not a git repository: ${repoPath}`);\n            }\n\n            // 2. Stage archivos usando GitExecutor\n            if (files && files.length > 0) {\n                // Stage archivos espec√≠ficos\n                console.log(`[GitManager] Staging ${files.length} specific files`);\n                for (const file of files) {\n                    try {\n                        await GitExecutor.exec(`add \"${file}\"`, { cwd: repoPath });\n                    } catch (error: any) {\n                        console.warn(`[GitManager] Could not stage ${file}:`, error.message);\n                        // Continuar con otros archivos\n                    }\n                }\n            } else {\n                // Stage todo\n                console.log(`[GitManager] Staging all changes`);\n                await GitExecutor.exec('add .', { cwd: repoPath });\n            }\n\n            // 3. Verificar que hay cambios staged\n            const { stdout: stagedFiles } = await GitExecutor.exec(\n                'diff --cached --name-only',\n                { cwd: repoPath }\n            );\n\n            if (!stagedFiles.trim()) {\n                vscode.window.showInformationMessage(\n                    `‚úî No hay cambios nuevos en ${repoName}`\n                );\n                console.log(`[GitManager] No staged changes in ${repoName}`);\n                return;\n            }\n\n            const changedFilesList = stagedFiles.trim().split('\\n').filter(f => f);\n            console.log(`[GitManager] ${changedFilesList.length} files staged`);\n\n            // 4. Intentar pre-llenar mensaje de commit usando Git Extension API\n            if (commitMessage) {\n                await this.trySetCommitMessage(repoPath, commitMessage);\n            }\n\n            // 5. Enfocar en SCM panel\n            await vscode.commands.executeCommand('workbench.view.scm');\n\n            // 6. Intentar enfocar en el repo espec√≠fico (importante en multi-root)\n            try {\n                await vscode.commands.executeCommand('workbench.scm.focus');\n            } catch (error) {\n                // No cr√≠tico\n                console.warn('[GitManager] Could not focus SCM:', error);\n            }\n\n            // 7. Mostrar notificaci√≥n NO BLOQUEANTE\n            const filePreview = changedFilesList.slice(0, 5).join('\\n');\n            const moreFiles = changedFilesList.length > 5\n                ? `\\n... y ${changedFilesList.length - 5} m√°s`\n                : '';\n\n            const action = await vscode.window.showInformationMessage(\n                `üìù ${changedFilesList.length} archivo(s) preparado(s) en ${repoName}`,\n                {\n                    modal: false, // NO BLOQUEANTE\n                    detail: `Revis√° los cambios en el panel SCM.\\n\\nArchivos:\\n${filePreview}${moreFiles}`\n                },\n                'Ver SCM'\n            );\n\n            if (action === 'Ver SCM') {\n                await vscode.commands.executeCommand('workbench.view.scm');\n            }\n\n            console.log(`[GitManager] Successfully staged and opened SCM for ${repoName}`);\n\n        } catch (error: any) {\n            console.error('[GitManager] Error in stageAndOpenSCM:', error);\n            vscode.window.showErrorMessage(\n                `Error preparando cambios: ${error.message}`\n            );\n            throw error; // Re-throw para que el caller sepa que fall√≥\n        }\n    }\n\n    private static async trySetCommitMessage(\n        repoPath: string,\n        message: string\n    ): Promise<void> {\n        try {\n            const gitExtension = vscode.extensions.getExtension('vscode.git');\n            if (!gitExtension) {\n                console.warn('[GitManager] Git extension not found');\n                return;\n            }\n\n            const gitApi = gitExtension.exports.getAPI(1);\n\n            // Buscar el repositorio que coincide con el path\n            const repo = gitApi.repositories.find(\n                (r: any) => r.rootUri.fsPath === repoPath\n            );\n\n            if (repo && repo.inputBox) {\n                repo.inputBox.value = message;\n                console.log('[GitManager] Commit message pre-filled successfully');\n            } else {\n                console.warn('[GitManager] Repository not found in Git API');\n            }\n        } catch (error: any) {\n            // Fallo silencioso - no es cr√≠tico\n            console.warn('[GitManager] Could not set commit message:', error.message);\n        }\n    }\n\n    static getPendingCount(): number {\n        return this.pendingCommits.length;\n    }\n\n    static clearPending(): void {\n        this.pendingCommits = [];\n        this.updateStatusBar();\n    }\n}"
        }
    ]
}