import{w as h}from"./svelte.js";const i="http://localhost:48215/api/v1";class f extends Error{constructor(o,r,t){super(o),this.status=r,this.details=t,this.name="ApiError"}}async function c(s){if(!s.ok){const o=await s.json().catch(()=>({error:"Unknown error"}));throw new f(o.error||o.message||"Request failed",s.status,o)}return s.json()}async function p(s,o){const r=new URLSearchParams({nucleus:s}),t=await fetch(`${i}/intent/list?${r}`);return c(t)}async function y(s,o){const r=new URLSearchParams({id:s,nucleus:o}),t=await fetch(`${i}/intent/get?${r}`);return c(t)}async function b(s,o){const r=await fetch(`${i}/intent/finalize`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:s,nucleus:o})});return c(r)}function m(){const{subscribe:s,set:o,update:r}=h({list:[],current:null,wizardState:"briefing",nucleusPath:""});return{subscribe:s,setNucleusPath(t){r(e=>({...e,nucleusPath:t}))},async load(t){try{let e=t;if(e||(e=(await new Promise(l=>{const d=s(w=>{d(),l(w)})})).nucleusPath),!e)return console.warn("No nucleus path provided"),[];const a=(await p(e)).intents||[];return r(u=>({...u,list:a})),a}catch(e){return console.error("Failed to load intents:",e),[]}},async loadIntent(t,e){try{const n=await y(t,e);r(a=>({...a,current:n}))}catch(n){console.error("Failed to load intent:",n)}},createNew(){const t={id:"new",type:"doc",name:"New Intent",profile:"main",project:"",status:"draft",briefing:{problem:"",expectedOutput:"",currentBehavior:"",desiredBehavior:"",considerations:""},questions:[{label:"Question 1",answer:""},{label:"Question 2",answer:""},{label:"Question 3",answer:""},{label:"Question 4",answer:""},{label:"Question 5",answer:""}],turns:[],files:[]};r(e=>({...e,current:t,wizardState:"briefing"}))},setWizardState(t){r(e=>({...e,wizardState:t}))},async execute(t,e){try{return console.log("Execution started for intent:",t),{status:"started"}}catch(n){throw console.error("Execution failed:",n),n}},async finalize(t,e){try{await b(t,e),console.log("Intent finalized:",t)}catch(n){throw console.error("Finalization failed:",n),n}},async addTurn(t,e){r(n=>n.current&&n.current.id===t?{...n,current:{...n.current,turns:[...n.current.turns||[],e]}}:n),setTimeout(()=>{const n={id:Date.now().toString(),actor:"ai",content:"Processing your request...",timestamp:new Date().toISOString()};r(a=>a.current&&a.current.id===t?{...a,current:{...a.current,turns:[...a.current.turns||[],n]}}:a)},1e3)}}}const S=m();export{S as i};
