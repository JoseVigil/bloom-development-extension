"""
Profile Launcher - L√≥gica aislada de lanzamiento de perfiles.
Versi√≥n spec-driven pura: Solo acepta especificaciones JSON.
Convention mode eliminado - deprecated desde v2.0.

CHANGELOG v3.0:
- Config file generation delegated to Sentinel (Go)
- Brain now ONLY starts Chrome process with provided args
- All session identity (launch_id, synapse configs) managed by Sentinel
- Simplified error handling and launch contract

CHANGELOG v2.4:
- Error handling estructurado con c√≥digos y data
- Clasificaci√≥n de errores (fatales vs recuperables)
- Manejo robusto de condiciones de carrera
- Agregado soporte para page_config (discovery/landing)
- Generaci√≥n autom√°tica de target_url seg√∫n page_config.type

IMPORTANT: Configuration Files
==============================
The *.synapse.config.js files (discovery.synapse.config.js, landing.synapse.config.js)
are generated by Sentinel (Go) in ignition_identity.go::prepareSessionFiles().

This ensures:
1. Single source of truth for session identity
2. Atomic generation with launch_id
3. No Python/Go race conditions
4. Proper override application before Chrome starts

Brain's responsibility is ONLY to launch Chrome with the provided arguments.
"""
import sys
import json
import subprocess
import os
import uuid
import platform
import time
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime

from brain.shared.logger import get_logger
from brain.core.profile.bloom_launcher_client import LauncherClient, LauncherUnavailableError

logger = get_logger("brain.profile.launcher")


class LaunchError(Exception):
    """Base exception para errores de lanzamiento."""
    def __init__(self, message: str, code: str, data: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.code = code
        self.data = data or {}


class ProfileLauncher:
    """
    Lanzador de perfiles con handoff estandarizado a Sentinel.
    SOLO soporta spec-driven mode - todos los par√°metros vienen del JSON.
    
    NOTE: Config file generation (*.synapse.config.js) is handled by Sentinel
    before calling this launcher. Brain only starts Chrome with provided args.
    """
    
    # Error codes (clasificados por severidad)
    ERROR_PROFILE_NOT_FOUND = "PROFILE_NOT_FOUND"           # Fatal
    ERROR_SPEC_INVALID = "SPEC_INVALID"                     # Fatal
    ERROR_CHROME_NOT_FOUND = "CHROME_NOT_FOUND"             # Fatal
    ERROR_EXTENSION_NOT_FOUND = "EXTENSION_NOT_FOUND"       # Fatal
    ERROR_CHROME_ALREADY_RUNNING = "CHROME_ALREADY_RUNNING" # Recuperable
    ERROR_PORT_IN_USE = "PORT_IN_USE"                       # Recuperable
    ERROR_LAUNCH_FAILED = "LAUNCH_FAILED"                   # Fatal
    
    def __init__(self, paths, chrome_resolver):
        """
        Args:
            paths: PathResolver instance
            chrome_resolver: ChromeResolver instance (unused en spec-driven)
        """
        self.paths = paths
        self.resolver = chrome_resolver
        self.launcher_client = LauncherClient(paths.base_dir)
        logger.debug("ProfileLauncher inicializado (spec-driven only)")
    
    def launch(
        self,
        profile: Dict[str, Any],
        url: Optional[str] = None,
        spec_data: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Lanza un perfil usando especificaci√≥n JSON.
        
        IMPORTANT: Assumes all config files (*.synapse.config.js) have been
        generated by Sentinel before this call. Brain only starts Chrome.
        
        Args:
            profile: Datos del perfil (id, alias, path)
            url: IGNORADO - deprecated
            spec_data: Especificaci√≥n completa (REQUERIDO)
        
        Returns:
            Dict con resultado estructurado (success o error)
            
        Raises:
            LaunchError: Con c√≥digo y data espec√≠ficos
        """
        logger.info(f"üöÄ Lanzando perfil: {profile['id'][:8]}...")
        logger.debug("‚ÑπÔ∏è  Config files assumed pre-generated by Sentinel")
        
        try:
            if not spec_data:
                raise LaunchError(
                    "Spec-driven mode required. Convention mode deprecated since v2.0.",
                    self.ERROR_SPEC_INVALID
                )
            
            logger.info("üìã Modo SPEC-DRIVEN")
            return self._launch_spec_driven(profile, spec_data)
            
        except LaunchError:
            raise  # Re-raise con mismo c√≥digo
        except Exception as e:
            # Wrap unexpected errors
            logger.error(f"‚ùå Unexpected launch error: {e}", exc_info=True)
            raise LaunchError(
                f"Unexpected error during launch: {str(e)}",
                self.ERROR_LAUNCH_FAILED,
                {"original_error": str(e)}
            )
    
    def _launch_spec_driven(self, profile: Dict[str, Any], spec: Dict[str, Any]) -> Dict[str, Any]:
        """
        Lanzamiento spec-driven: JSON define TODO (executable, paths, flags, url).
        
        Returns:
            Dict estructurado con status/message/data
            
        Raises:
            LaunchError: Con c√≥digo espec√≠fico del error
        """
        logger.info("üéØ Ejecutando spec-driven v3.0 (config-less)")
        
        try:
            # Extracci√≥n de configuraci√≥n
            engine_config = spec.get('engine', {})
            paths_config = spec.get('paths', {})
            page_config = spec.get('page_config', {})
            
            engine_type = engine_config.get('type')
            exe = engine_config.get('executable')
            u_data = paths_config.get('user_data')
            ext = paths_config.get('extension')
            logs_base = paths_config.get('logs_base')
            target_url_raw = spec.get('target_url')
            
            logger.debug(f"üìã Spec recibido:")
            logger.debug(f"   Engine Type: {engine_type}")
            logger.debug(f"   Executable: {exe}")
            logger.debug(f"   User Data: {u_data}")
            logger.debug(f"   Extension: {ext}")
            logger.debug(f"   Target URL (raw): {target_url_raw}")
            logger.debug(f"   Page Config: {page_config}")
            
            # Validaci√≥n de campos requeridos
            if not all([engine_type, exe, u_data, ext]):
                missing = []
                if not engine_type: missing.append('engine.type')
                if not exe: missing.append('engine.executable')
                if not u_data: missing.append('paths.user_data')
                if not ext: missing.append('paths.extension')
                
                raise LaunchError(
                    f"Spec incompleto. Campos faltantes: {', '.join(missing)}",
                    self.ERROR_SPEC_INVALID,
                    {"missing_fields": missing}
                )
            
            # Validaci√≥n de engine type
            if engine_type not in ['chrome', 'chromium']:
                raise LaunchError(
                    f"Engine type inv√°lido: '{engine_type}'. Permitidos: chrome, chromium",
                    self.ERROR_SPEC_INVALID,
                    {"provided_type": engine_type, "valid_types": ["chrome", "chromium"]}
                )
            
            # Resoluci√≥n de target_url
            target_url = self._resolve_target_url(target_url_raw, page_config)
            
            page_type = page_config.get('type', 'custom')
            if page_type == 'discovery':
                logger.info(f"üîé Lanzando en modo DISCOVERY")
                logger.info(f"   ‚Üí Onboarding y validaci√≥n inicial")
            elif page_type == 'landing':
                logger.info(f"üè† Lanzando en modo LANDING")
                logger.info(f"   ‚Üí Dashboard del perfil")
            else:
                logger.info(f"üéØ Lanzando en modo CUSTOM")
            
            logger.info(f"üéØ Target URL resuelto: {target_url}")
            
            # Resoluci√≥n de rutas (relativas a base_dir o absolutas)
            exec_path = self.paths.base_dir / exe if not os.path.isabs(exe) else Path(exe)
            user_data_path = self.paths.base_dir / u_data if not os.path.isabs(u_data) else Path(u_data)
            extension_path = self.paths.base_dir / ext if not os.path.isabs(ext) else Path(ext)
            
            logger.debug(f"üîß Rutas resueltas:")
            logger.debug(f"   Executable: {exec_path}")
            logger.debug(f"   User Data: {user_data_path}")
            logger.debug(f"   Extension: {extension_path}")
            
            # Validaci√≥n de existencia
            if not exec_path.exists():
                raise LaunchError(
                    f"Chrome executable not found: {exec_path}",
                    self.ERROR_CHROME_NOT_FOUND,
                    {"path": str(exec_path)}
                )
            
            if not extension_path.exists():
                raise LaunchError(
                    f"Extension directory not found: {extension_path}",
                    self.ERROR_EXTENSION_NOT_FOUND,
                    {"path": str(extension_path)}
                )
            
            # Construcci√≥n de args base
            args = [
                str(exec_path),
                f"--user-data-dir={user_data_path}",
                f"--load-extension={extension_path}",
                "--no-first-run",
                "--no-default-browser-check"
            ]
            
            # Agregar engine_flags si existen
            engine_flags = spec.get('engine_flags', [])
            if engine_flags:
                args.extend(engine_flags)
                logger.debug(f"   + {len(engine_flags)} engine flags")
            
            # Agregar custom_flags si existen
            custom_flags = spec.get('custom_flags', [])
            if custom_flags:
                args.extend(custom_flags)
                logger.debug(f"   + {len(custom_flags)} custom flags")
            
            # Agregar target_url al final
            args.append(target_url)
            
            # Preparar logs
            if logs_base:
                logs_path = self.paths.base_dir / logs_base if not os.path.isabs(logs_base) else Path(logs_base)
                logs_path.mkdir(parents=True, exist_ok=True)
                
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                debug_log = str(logs_path / f"debug_{timestamp}.log")
                net_log = str(logs_path / f"net_{timestamp}.log")
                
                args.extend([
                    f"--enable-logging=stderr",
                    f"--log-level=0",
                    f"--log-net-log={net_log}"
                ])
                
                log_files = {
                    "debug_log": debug_log,
                    "net_log": net_log
                }
            else:
                log_files = {}
            
            # Extraer launch_id del spec si existe
            launch_id = spec.get('launch_id')
            
            logger.info(f"‚úÖ Spec validado. Preparando handoff...")
            logger.debug(f"   Total args: {len(args)}")
            
            # Ejecutar handoff
            return self._execute_handoff(args, profile['id'], log_files, launch_id)
            
        except LaunchError:
            raise
        except Exception as e:
            logger.error(f"‚ùå Error en spec-driven launch: {e}", exc_info=True)
            raise LaunchError(
                f"Spec-driven launch failed: {str(e)}",
                self.ERROR_LAUNCH_FAILED,
                {"stage": "spec_processing", "error": str(e)}
            )
    
    def _resolve_target_url(self, target_url_raw: Optional[str], page_config: Dict[str, Any]) -> str:
        """
        Resuelve el target_url seg√∫n el spec y page_config.
        
        L√≥gica:
        1. Si target_url == None y page_config.type in [discovery, landing] ‚Üí auto-generate
        2. Si target_url == "auto" ‚Üí SIEMPRE auto-generate (requiere page_config.type v√°lido)
        3. Si target_url especificado ‚Üí usar como est√°
        4. Si target_url == None y page_config.type == 'custom' ‚Üí error
        
        Returns:
            URL resuelta (string)
            
        Raises:
            LaunchError: Si configuraci√≥n inv√°lida
        """
        try:
            page_type = page_config.get('type', 'custom')
            auto_generate = page_config.get('auto_generate', False)
            
            # Validar page_type
            valid_types = ['discovery', 'landing', 'custom']
            if page_type not in valid_types:
                raise LaunchError(
                    f"Invalid page_config.type: '{page_type}'",
                    self.ERROR_SPEC_INVALID,
                    {"provided": page_type, "valid": valid_types}
                )
            
            # Caso 1: target_url no especificado + page_type espec√≠fico ‚Üí auto
            if not target_url_raw and page_type in ['discovery', 'landing']:
                logger.debug(f"  ‚Üí Auto-generando URL para page_type={page_type}")
                auto_generate = True
            
            # Caso 2: page_type == custom SIEMPRE requiere target_url manual
            if page_type == 'custom' and not target_url_raw:
                raise LaunchError(
                    "page_config.type='custom' requires manual target_url",
                    self.ERROR_SPEC_INVALID,
                    {"provided": page_type, "valid": valid_types}
                )
            
            # Caso 3: target_url == "auto" ‚Üí Generar seg√∫n page_type
            if target_url_raw == "auto" or auto_generate:
                if page_type == 'custom':
                    raise LaunchError(
                        "Cannot auto-generate URL for page_config.type='custom'",
                        self.ERROR_SPEC_INVALID,
                        {"suggestion": "Use 'discovery' or 'landing', or provide manual target_url"}
                    )
                
                extension_id = self.paths.get_extension_id()
                
                if page_type == 'discovery':
                    url = f"chrome-extension://{extension_id}/discovery/index.html"
                    logger.info(f"üîé Modo DISCOVERY: {url}")
                    logger.info("   ‚Üí P√°gina de onboarding y validaci√≥n inicial")
                elif page_type == 'landing':
                    url = f"chrome-extension://{extension_id}/landing/index.html"
                    logger.info(f"üè† Modo LANDING: {url}")
                    logger.info("   ‚Üí Dashboard del perfil (panel de control)")
                
                return url
            
            # Caso 4: target_url manual especificado
            if target_url_raw:
                logger.info(f"üéØ Modo CUSTOM: Usando target_url manual")
                logger.debug(f"   URL: {target_url_raw}")
                return target_url_raw
            
            # Caso 5: Ni auto ni manual ‚Üí Error
            raise LaunchError(
                "target_url not specified. Use 'auto' or provide manual URL",
                self.ERROR_SPEC_INVALID,
                {"page_type": page_type}
            )
            
        except LaunchError:
            raise
        except Exception as e:
            raise LaunchError(
                f"Failed to resolve target_url: {str(e)}",
                self.ERROR_SPEC_INVALID,
                {"error": str(e)}
            )
    
    def _execute_handoff(
        self, 
        args: list, 
        profile_id: str, 
        log_files: Dict[str, str],
        launch_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Handoff est√°ndar a Sentinel (Go) con error handling robusto.
        Implementa el contrato Python -> Go v3.0.
        
        Returns:
            Dict estructurado con resultado
            
        Raises:
            LaunchError: Con c√≥digo espec√≠fico del error
        """
        logger.info(f"üöÄ Iniciando handoff a Sentinel")
        logger.debug(f"  ‚Üí Args count: {len(args)}")
        logger.debug(f"  ‚Üí Executable: {args[0]}")

        try:
            # ==========================================================
            # FIX DEFINITIVO ‚Äì LOCK AT√ìMICO A NIVEL SO
            # ==========================================================

            # Extraer --user-data-dir
            user_data_arg = next(
                (a for a in args if a.startswith("--user-data-dir=")),
                None
            )

            if not user_data_arg:
                raise LaunchError(
                    "Missing --user-data-dir in Chrome args",
                    self.ERROR_SPEC_INVALID,
                    {"args": args}
                )

            user_data_path = Path(user_data_arg.split("=", 1)[1])
            lock_file = user_data_path / ".chrome_app.lock"

            # üßπ Limpiar lock previo siempre
            if lock_file.exists():
                lock_file.unlink()
                logger.debug("üßπ Lock previo eliminado")

            try:
                # CREACI√ìN AT√ìMICA: solo UN proceso puede pasar
                fd = os.open(
                    lock_file,
                    os.O_CREAT | os.O_EXCL | os.O_WRONLY
                )
                with os.fdopen(fd, "w") as f:
                    f.write(
                        f"pid={os.getpid()}\n"
                        f"time={datetime.now().isoformat()}\n"
                    )

                logger.debug("üîí Lock de app creado correctamente")

            except FileExistsError:
                logger.warning("üö´ Launch abortado: Chrome ya en ejecuci√≥n")
                
                # Leer PID del lock existente (si es posible)
                existing_pid = None
                try:
                    with open(lock_file, 'r') as f:
                        for line in f:
                            if line.startswith('pid='):
                                existing_pid = int(line.split('=')[1].strip())
                except:
                    pass
                
                raise LaunchError(
                    f"Chrome already running for profile {profile_id[:8]}",
                    self.ERROR_CHROME_ALREADY_RUNNING,
                    {
                        "profile_id": profile_id,
                        "lock_file": str(lock_file),
                        "existing_pid": existing_pid
                    }
                )

            # ==========================================================
            # Kill preventivo de bloom-host (Windows only)
            # ==========================================================
            if platform.system() == 'Windows':
                logger.debug("üî™ Matando procesos bloom-host.exe previos")
                os.system('taskkill /f /im bloom-host.exe >nul 2>&1')

            # ======================================================
            # 1. SILENCIO TOTAL EN STDOUT
            # ======================================================
            import logging
            logging.disable(logging.CRITICAL)

            # ======================================================
            # 2. LANZAMIENTO DESACOPLADO
            # ======================================================
            logger.info("üöÄ Spawning proceso desacoplado...")

            if platform.system() == 'Windows':
                # Windows: delegar a bloom-launcher (Session 1) via named pipe.
                # Raz√≥n: Brain corre en Session 0 (NSSM service) sin acceso al
                # compositor de ventanas (DComposition). bloom-launcher corre en
                # Session 1 (sesi√≥n interactiva del usuario) y puede crear
                # ventanas de Chromium visibles.
                try:
                    logger.info("üåâ Delegando a bloom-launcher (Session 1)...")
                    chrome_pid = self.launcher_client.launch_chrome(args, profile_id)
                    logger.info(f"‚úÖ Chrome lanzado via bloom-launcher PID={chrome_pid}")

                    class _FakeProc:
                        """Shim que expone .pid igual que subprocess.Popen."""
                        def __init__(self, pid: int):
                            self.pid = pid

                    proc = _FakeProc(chrome_pid)

                except LauncherUnavailableError as exc:
                    logger.error(f"‚ùå bloom-launcher no disponible: {exc}")
                    raise LaunchError(
                        f"Launcher de sesi√≥n no disponible: {exc}. "
                        "Aseg√∫rese de que bloom-launcher.exe est√© corriendo "
                        "en la sesi√≥n del usuario.",
                        self.ERROR_LAUNCH_FAILED,
                        {"stage": "session_launcher", "error": str(exc)},
                    )
            else:
                # macOS / Linux: Popen directo (no tienen Session 0 isolation).
                proc = subprocess.Popen(
                    args,
                    creationflags=0,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    stdin=subprocess.DEVNULL,
                    close_fds=True,
                    shell=False,
                )

            # ======================================================
            # 3. CONTRATO JSON
            # ======================================================
            if not launch_id:
                launch_id = datetime.now().strftime("%Y%m%d_%H%M%S")

            result = {
                "status": "success",
                "message": "Profile launched successfully",
                "data": {
                    "profile_id": profile_id,
                    "launch": {
                        "pid": proc.pid,
                        "launch_id": launch_id
                    },
                    "log_files": log_files
                }
            }

            # ======================================================
            # 4. ENTREGA Y CIERRE QUIR√öRGICO
            # ======================================================
            sys.stdout.write(json.dumps(result) + "\n")
            sys.stdout.flush()

            time.sleep(0.5)
            os._exit(0)

        except LaunchError:
            raise  # Re-raise con c√≥digo original
        except Exception as e:
            logger.error(f"‚ùå Error fatal en handoff: {e}", exc_info=True)
            raise LaunchError(
                f"Handoff failed: {str(e)}",
                self.ERROR_LAUNCH_FAILED,
                {"stage": "handoff", "error": str(e)}
            )