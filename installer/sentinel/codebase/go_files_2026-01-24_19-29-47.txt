internal\seed\seed.go

```go
package seed

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sentinel/internal/core"
	"sentinel/internal/discovery"
	"sentinel/internal/startup"
	"strings"
	"time"

	"golang.org/x/sys/windows/registry"
)

type ProfileEntry struct {
	ID            string `json:"id"`
	Alias         string `json:"alias"`
	Master        bool   `json:"master"`
	Path          string `json:"path"`
	SpecPath      string `json:"spec_path"`
	ConfigDir     string `json:"config_dir"`
	LogsDir       string `json:"logs_dir"`
	ExtensionPath string `json:"extension_path"`
	LaunchCount   int    `json:"launch_count"`
}

type ProfilesRegistry struct {
	Profiles []ProfileEntry `json:"profiles"`
}

func HandleSeed(c *core.Core, alias string, isMaster bool) (string, error) {
	registry_data := loadProfilesRegistry(c)
	for _, p := range registry_data.Profiles {
		if p.Alias == alias {
			return "", fmt.Errorf("alias_duplicado: %s", alias)
		}
	}

	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	cmd := exec.Command(sm.BrainPath, "--json", "profile", "create", alias)
	var out bytes.Buffer
	cmd.Stdout = &out
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("brain_error: %v", err)
	}

	rawOut := strings.TrimSpace(out.String())
	jsonStart := strings.LastIndex(rawOut, "{")
	jsonEnd := strings.LastIndex(rawOut, "}")
	if jsonStart == -1 || jsonEnd == -1 {
		return "", fmt.Errorf("formato_invalido: %s", rawOut)
	}

	var brainRes struct{ UUID string `json:"uuid"` }
	if err := json.Unmarshal([]byte(rawOut[jsonStart:jsonEnd+1]), &brainRes); err != nil {
		return "", err
	}
	uuid := brainRes.UUID

	// Rutas Base del Perfil
	profileDir := filepath.Join(c.Paths.ProfilesDir, uuid)
	extDir := filepath.Join(profileDir, "extension")
	logsDir := filepath.Join(c.Paths.LogsDir, "profiles", uuid)
	configDir := filepath.Join(c.Paths.AppDataDir, "config", "profile", uuid)
	specPath := filepath.Join(configDir, "ignition_spec.json")

	_ = os.MkdirAll(configDir, 0755)
	_ = os.MkdirAll(extDir, 0755)
	_ = os.MkdirAll(logsDir, 0755)

	// 1. ESCRIBIR MANIFIESTO NATIVO
	shortID := uuid[:8]
	hostName := fmt.Sprintf("com.bloom.synapse.%s", shortID)
	manifestPath := filepath.Join(configDir, hostName+".json")
	if err := writeNativeManifest(c, manifestPath, hostName, uuid); err != nil {
		return "", err
	}

	// 2. REGISTRO DE WINDOWS (HKCU)
	if err := registerInWindows(hostName, manifestPath); err != nil {
		c.Logger.Error("[SEED] No se pudo registrar Native Messaging: %v", err)
	}

	// 3. GENERAR SPEC CON TEMPLATE DE ORO (AJUSTE CRÃTICO 3)
	_ = writeIgnitionSpec(c, sm, uuid, profileDir, extDir, logsDir, specPath)

	updateProfilesInventory(c, uuid, alias, isMaster, profileDir, configDir, extDir, logsDir, specPath)

	if isMaster {
		status := startup.LoadCurrentStatus(c)
		status.MasterProfile = uuid
		status.Timestamp = time.Now().Format(time.RFC3339)
		_ = startup.SaveSystemStatus(c, status)
	}

	return uuid, nil
}

func writeNativeManifest(c *core.Core, path, hostName, uuid string) error {
	// AJUSTE CRÃTICO 1: El binario es bloom-host.exe dentro de bin/native/
	bridgePath := filepath.Join(c.Paths.BinDir, "native", "bloom-host.exe")
	
	manifest := map[string]interface{}{
		"name":        hostName,
		"description": "Synapse v2 Native Bridge Host",
		"path":        bridgePath,
		"type":        "stdio",
		"allowed_origins": []string{
			fmt.Sprintf("chrome-extension://%s/", c.Config.Provisioning.ExtensionID),
		},
		"args": []string{"--profile-id", uuid},
	}
	data, _ := json.MarshalIndent(manifest, "", "  ")
	return os.WriteFile(path, data, 0644)
}

func registerInWindows(hostName, manifestPath string) error {
	keyPath := `Software\Google\Chrome\NativeMessagingHosts\` + hostName
	k, _, err := registry.CreateKey(registry.CURRENT_USER, keyPath, registry.ALL_ACCESS)
	if err != nil { return err }
	defer k.Close()
	return k.SetStringValue("", manifestPath)
}

func writeIgnitionSpec(c *core.Core, sm *discovery.SystemMap, uuid, profileDir, extDir, logsDir, specPath string) error {
	spec := map[string]interface{}{
		"engine": map[string]string{
			"executable": sm.ChromePath,
			"type":       "chromium",
		},
		"engine_flags": []string{
			"--no-sandbox",
			"--test-type",
			"--disable-web-security",
			// AJUSTE CRÃTICO 3: Sin espacios en la lista de features
			"--disable-features=IsolateOrigins,site-per-process",
			"--allow-running-insecure-content",
			"--no-first-run",
			"--no-default-browser-check",
			"--disable-sync",
			"--remote-debugging-port=0",
			"--enable-logging",
			"--v=1",
			"--disable-session-crashed-bubble",
		},
		"paths": map[string]string{
			"extension": extDir,
			"logs_base":  logsDir,
			"user_data":  profileDir,
		},
		"target_url":   fmt.Sprintf("chrome-extension://%s/discovery/index.html", c.Config.Provisioning.ExtensionID),
		"custom_flags": []string{},
	}
	data, _ := json.MarshalIndent(spec, "", "  ")
	return os.WriteFile(specPath, data, 0644)
}

func updateProfilesInventory(c *core.Core, uuid, alias string, isMaster bool, profileDir, configDir, extDir, logsDir, specPath string) {
	registry_data := loadProfilesRegistry(c)
	newEntry := ProfileEntry{
		ID:            uuid,
		Alias:         alias,
		Master:        isMaster,
		Path:          profileDir,
		ConfigDir:     configDir,
		SpecPath:      specPath,
		LogsDir:       logsDir,
		ExtensionPath: extDir,
		LaunchCount:   0,
	}

	for i, p := range registry_data.Profiles {
		if isMaster { registry_data.Profiles[i].Master = false }
		if p.ID == uuid {
			newEntry.LaunchCount = p.LaunchCount
			registry_data.Profiles[i] = newEntry
			saveRegistry(c, registry_data)
			return
		}
	}
	registry_data.Profiles = append(registry_data.Profiles, newEntry)
	saveRegistry(c, registry_data)
}

func saveRegistry(c *core.Core, reg ProfilesRegistry) {
	path := filepath.Join(c.Paths.AppDataDir, "config", "profiles.json")
	data, _ := json.MarshalIndent(reg, "", "  ")
	_ = os.WriteFile(path, data, 0644)
}

func loadProfilesRegistry(c *core.Core) ProfilesRegistry {
	path := filepath.Join(c.Paths.AppDataDir, "config", "profiles.json")
	data, err := os.ReadFile(path)
	if err != nil { return ProfilesRegistry{Profiles: []ProfileEntry{}} }
	var registry_data ProfilesRegistry
	if err := json.Unmarshal(data, &registry_data); err != nil {
		var list []ProfileEntry
		json.Unmarshal(data, &list)
		registry_data.Profiles = list
	}
	return registry_data
}
```

--------------------------------------------------------------------------------

main.go

```go
package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"strconv"
	"sentinel/internal/ui"
	"sentinel/internal/boot"
	"sentinel/internal/core"
	"sentinel/internal/discovery"
	"sentinel/internal/health"
	"sentinel/internal/persistence"
	"sentinel/internal/ignition"
	"sentinel/internal/startup" 
	"sentinel/internal/seed"    
	"syscall"
	"time"
)

// RPCRequest define la estructura de comandos entrantes desde Electron
type RPCRequest struct {
	Method string          `json:"method"`
	Params json.RawMessage `json:"params"`
}

func main() {
	// 1. InicializaciÃ³n del Core (Config y Paths)
	c, err := core.Initialize()
	if err != nil {
		fmt.Fprintf(os.Stderr, "âœ— Error fatal de inicializaciÃ³n: %v\n", err)
		os.Exit(1)
	}
	defer c.Close()

	// 2. FASE STARTUP: Identidad, Manifiesto y Estado Inicial
	if err := startup.Initialize(c); err != nil {
		c.Logger.Error("Fallo crÃ­tico en fase Startup: %v", err)
		os.Exit(1)
	}

	// 3. ENRUTADOR DE COMANDOS CLI
	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "health":
			runHealthCommand(c)
			return

		case "seed":
			if len(os.Args) < 4 {
				c.Logger.Error("Uso: sentinel seed [alias] [is_master (true|false)]")
				os.Exit(1)
			}
			alias := os.Args[2]
			isMaster, _ := strconv.ParseBool(os.Args[3])
			runSeedCommand(c, alias, isMaster)
			return

		case "bridge":
			runBridgeMode(c)
			return

		case "dev-start":
			runDevStartCommand(c)
			return

		case "launch":
			if len(os.Args) < 3 {
				c.Logger.Error("Uso: sentinel launch [profile_id] [--cockpit|--discovery]")
				os.Exit(1)
			}
			profileID := os.Args[2]
			mode := "--cockpit"
			if len(os.Args) > 3 {
				mode = os.Args[3]
			}
			runLaunchCommand(c, profileID, mode)
			return

		case "cockpit":
			runCockpit(c)
			return
		}
	}

	// Salida por defecto si no hay argumentos
	c.Logger.Success("Sentinel Base v%s activa y sincronizada.", c.Config.Version)
	fmt.Println(c.Paths.String())
}

// ============================================================================
// BRAIN SERVICE MANAGEMENT
// ============================================================================

// checkBrainHealth verifica que Brain Service estÃ© realmente funcional
func checkBrainHealth(c *core.Core) error {
	c.Logger.Info("ðŸ” Verificando Brain Service...")
	
	// Intento 1: Check TCP bÃ¡sico
	conn, err := net.DialTimeout("tcp", "127.0.0.1:5678", 2*time.Second)
	if err != nil {
		return fmt.Errorf("Brain Service no responde en puerto 5678: %w", err)
	}
	conn.Close()
	
	c.Logger.Success("âœ“ Brain Service detectado en puerto 5678")
	
	// Intento 2: Validar que acepte conexiones (enviar ping simple)
	conn, err = net.Dial("tcp", "127.0.0.1:5678")
	if err != nil {
		return fmt.Errorf("No se puede establecer conexiÃ³n con Brain: %w", err)
	}
	defer conn.Close()
	
	// Enviar mensaje de prueba (protocolo Brain: 4 bytes length + JSON)
	testMsg := []byte(`{"type":"HEALTH_PING"}`)
	length := uint32(len(testMsg))
	header := []byte{
		byte(length >> 24),
		byte(length >> 16),
		byte(length >> 8),
		byte(length),
	}
	
	conn.SetWriteDeadline(time.Now().Add(1 * time.Second))
	if _, err := conn.Write(append(header, testMsg...)); err != nil {
		return fmt.Errorf("Brain no acepta mensajes: %w", err)
	}
	
	c.Logger.Success("âœ“ Brain Service OPERATIVO")
	return nil
}

// startBrainService intenta arrancar Brain Service si no estÃ¡ corriendo
func startBrainService(c *core.Core) error {
	c.Logger.Info("ðŸš€ Iniciando Brain Service...")
	
	// Buscar el ejecutable de Brain
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	brainExe := sm.BrainPath
	
	if brainExe == "" || !fileExists(brainExe) {
		return fmt.Errorf("brain.exe no encontrado en: %s", c.Paths.BinDir)
	}
	
	c.Logger.Info("   Ejecutable: %s", brainExe)
	
	// Comando para iniciar Brain Service
	var cmd *exec.Cmd
	
	if runtime.GOOS == "windows" {
		// En Windows, usar start para ejecutar en background
		cmd = exec.Command("cmd", "/C", "start", "/B", brainExe, "service", "start", "--port", "5678")
	} else {
		cmd = exec.Command(brainExe, "service", "start", "--port", "5678", "--daemon")
	}
	
	if err := cmd.Start(); err != nil {
		return fmt.Errorf("No se pudo iniciar Brain: %w", err)
	}
	
	c.Logger.Info("   PID: %d", cmd.Process.Pid)
	
	// Esperar a que el puerto estÃ© disponible (mÃ¡ximo 10 segundos)
	for i := 0; i < 20; i++ {
		time.Sleep(500 * time.Millisecond)
		
		conn, err := net.DialTimeout("tcp", "127.0.0.1:5678", 500*time.Millisecond)
		if err == nil {
			conn.Close()
			c.Logger.Success("âœ“ Brain Service iniciado correctamente")
			return nil
		}
	}
	
	return fmt.Errorf("Brain Service no respondiÃ³ despuÃ©s de 10 segundos")
}

// ensureBrainRunning garantiza que Brain estÃ© operativo o falla
func ensureBrainRunning(c *core.Core) error {
	// Intento 1: Â¿EstÃ¡ corriendo?
	if err := checkBrainHealth(c); err == nil {
		return nil // Ya estÃ¡ corriendo
	}
	
	c.Logger.Warning("âš ï¸  Brain Service no detectado, intentando iniciar...")
	
	// Intento 2: Arrancarlo
	if err := startBrainService(c); err != nil {
		return fmt.Errorf("CRÃTICO: No se pudo arrancar Brain Service: %w", err)
	}
	
	// Intento 3: Verificar que ahora estÃ© funcionando
	time.Sleep(1 * time.Second)
	if err := checkBrainHealth(c); err != nil {
		return fmt.Errorf("Brain Service arrancÃ³ pero no responde: %w", err)
	}
	
	return nil
}

// ============================================================================
// DEV-START COMMAND (REFACTORED)
// ============================================================================

func runDevStartCommand(c *core.Core) {
	c.Logger.Info("ðŸš€ Iniciando Entorno de Desarrollo Integrado...")

	// âœ… PASO CRÃTICO: Asegurar que Brain estÃ© corriendo PRIMERO
	if err := ensureBrainRunning(c); err != nil {
		c.Logger.Error("âŒ %v", err)
		c.Logger.Error("")
		c.Logger.Error("SOLUCIÃ“N:")
		c.Logger.Error("  1. Verifica que brain.exe exista en: %s", c.Paths.BinDir)
		c.Logger.Error("  2. O inicia Brain manualmente:")
		c.Logger.Error("     brain.exe service start --port 5678")
		c.Logger.Error("")
		os.Exit(1)
	}

	// A. Discovery de herramientas de desarrollo
	codePath, _ := discovery.FindVSCodeBinary()
	extPath := c.Config.Settings.ExtensionPath
	wsPath := c.Config.Settings.TestWorkspace
	runtimePath := filepath.Join(c.Paths.AppDataDir, "resources", "runtime")

	// B. Registro de descubrimientos en nucleus.json
	startup.UpdateActiveStatus(c, map[string]string{
		"vscode_exe":        codePath,
		"vscode_workspace":  wsPath,
		"svelte_app_path":   filepath.Join(extPath, "webview", "app"),
		"operational_mode":  "development",
		"dev_runtime_path":  runtimePath,
		"brain_service":     "running", // âœ… Confirmado
	})

	// C. Lanzamiento de Svelte (Vite)
	svelteCmd, err := boot.LaunchSvelte(extPath)
	if err != nil {
		c.Logger.Warning("No se pudo iniciar Svelte: %v", err)
	}

	// D. SincronizaciÃ³n de Entorno VSCode
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	_ = boot.SyncVScodeSettings(extPath, sm.BrainPath, filepath.Join(runtimePath, "python.exe"))

	// E. Lanzamiento de VSCode Extension Host
	vsCmd, err := boot.LaunchExtensionHost(codePath, extPath, wsPath, runtimePath)
	if err != nil {
		c.Logger.Error("Fallo al lanzar VSCode: %v", err)
		if svelteCmd != nil { boot.KillProcessTree(svelteCmd.Process.Pid) }
		os.Exit(1)
	}

	// F. HEALTH CHECK MEJORADO
	c.Logger.Info("ðŸ” Validando estado del ecosistema...")
	time.Sleep(2 * time.Second)
	
	report, err := health.CheckHealth(c, sm)
	if err != nil {
		c.Logger.Warning("âš ï¸  Health check reportÃ³ errores: %v", err)
	} else {
		c.Logger.Success("âœ“ Estado del sistema actualizado en nucleus.json")
	}
	
	// Guardar estado actualizado
	persistence.SaveNucleusState(c, report)

	// G. Manejo de terminaciÃ³n
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	
	c.Logger.Info("")
	c.Logger.Success(">>> Entorno LISTO. Presiona Ctrl+C para cerrar todo.")
	c.Logger.Info("")
	<-sigs 

	fmt.Println()
	c.Logger.Info("ðŸ›‘ Finalizando procesos de desarrollo...")
	boot.KillProcessTree(vsCmd.Process.Pid)
	if svelteCmd != nil { boot.KillProcessTree(svelteCmd.Process.Pid) }
	boot.CleanPorts([]int{5173, 3001, 5678})
	c.Logger.Success("âœ“ Sistema limpio.")
}

// ============================================================================
// OTHER COMMANDS (Sin cambios)
// ============================================================================

func runSeedCommand(c *core.Core, alias string, isMaster bool) {
	uuid, err := seed.HandleSeed(c, alias, isMaster)
	if err != nil {
		res, _ := json.Marshal(map[string]string{"status": "error", "message": err.Error()})
		fmt.Println(string(res))
		os.Exit(1)
	}
	
	res, _ := json.Marshal(map[string]interface{}{
		"status": "success", 
		"uuid":   uuid, 
		"alias":  alias,
		"master": isMaster,
	})
	fmt.Println(string(res))
}

func runBridgeMode(c *core.Core) {
	c.Logger.Info("ðŸ“¡ Modo Bridge Activo (Esperando comandos JSON)")
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		var req RPCRequest
		if err := json.Unmarshal(scanner.Bytes(), &req); err != nil {
			sendError("JSON_PARSE_ERROR", err.Error())
			continue
		}

		switch req.Method {
		case "seed":
			var params struct { Alias string; Master bool }
			json.Unmarshal(req.Params, &params)
			uuid, err := seed.HandleSeed(c, params.Alias, params.Master)
			if err != nil {
				sendError("SEED_ERROR", err.Error())
			} else {
				sendResponse(map[string]string{"status": "success", "uuid": uuid})
			}
		case "health":
			sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
			report, _ := health.CheckHealth(c, sm)
			sendResponse(report)
		case "ping":
			sendResponse("pong")
		default:
			sendError("UNKNOWN_METHOD", req.Method)
		}
	}
}

func sendResponse(data interface{}) {
	res, _ := json.Marshal(map[string]interface{}{"result": data})
	fmt.Println(string(res))
}

func sendError(code, msg string) {
	res, _ := json.Marshal(map[string]interface{}{
		"error": map[string]string{"code": code, "message": msg},
	})
	fmt.Println(string(res))
}

func runHealthCommand(c *core.Core) {
	c.Logger.Info("ðŸ” Iniciando escaneo de integridad...")
	
	// âœ… Verificar Brain PRIMERO
	if err := checkBrainHealth(c); err != nil {
		c.Logger.Error("âŒ Brain Service: %v", err)
	} else {
		c.Logger.Success("âœ“ Brain Service: Operativo")
	}
	
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	report, err := health.CheckHealth(c, sm)
	if err != nil {
		c.Logger.Error("Error en Health: %v", err)
		return
	}
	
	// Sincronizar con el estado persistente
	persistence.SaveNucleusState(c, report)
	
	out, _ := json.MarshalIndent(report, "", "  ")
	fmt.Println(string(out))
}

func runLaunchCommand(c *core.Core, profileID string, mode string) {
	c.Logger.Info("ðŸ”¥ Sentinel Ignition: Perfil %s", profileID)
	
	// âœ… PRE-FLIGHT CHECK: Verificar Brain antes de lanzar
	if err := checkBrainHealth(c); err != nil {
		c.Logger.Error("âŒ PRE-FLIGHT FAILED: %v", err)
		c.Logger.Error("")
		c.Logger.Error("Brain Service debe estar corriendo antes de lanzar perfiles.")
		c.Logger.Error("Ejecuta: brain.exe service start --port 5678")
		c.Logger.Error("")
		os.Exit(1)
	}
	
	ig := ignition.New(c)
	ig.SetupReaper()
	
	if err := ig.Launch(profileID, mode); err != nil {
		c.Logger.Error("Fallo de lanzamiento: %v", err)
		os.Exit(1)
	}
	
	// Bloqueo para mantener la telemetrÃ­a viva hasta que el Reaper actÃºe
	select {} 
}

// ============================================================================
// HELPERS
// ============================================================================

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// ============================================================================
// UI COCKPIT
// ============================================================================

func runCockpit(c *core.Core) {
	// 1. Determinar el modo (default: log)
	mode := "log"
	if len(os.Args) > 2 && os.Args[2] == "--health" {
		mode = "health"
	}

	// 2. DelegaciÃ³n absoluta al orquestador modular
	ui.Launch(c, mode)
}
```

--------------------------------------------------------------------------------

