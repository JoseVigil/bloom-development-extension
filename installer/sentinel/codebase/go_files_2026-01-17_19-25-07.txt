main.go

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"sentinel/internal/core"
	"sentinel/internal/discovery"
	"sentinel/internal/health"
	"sentinel/internal/persistence"
)

func main() {
	c, err := core.Initialize()
	if err != nil {
		fmt.Fprintf(os.Stderr, "✗ Error fatal: %v\n", err)
		os.Exit(1)
	}
	defer c.Close()

	// Verificar si se pasó el comando "health"
	if len(os.Args) > 1 && os.Args[1] == "health" {
		runHealthCommand(c)
		return
	}

	// Comportamiento por defecto (inicialización base)
	c.Logger.Success("Sentinel Base Inicializada con éxito")
	fmt.Println()
	
	fmt.Print(c.Paths.String())
	fmt.Println()
	
	c.Logger.Success("Todas las rutas validadas correctamente")
	
	c.Logger.Info("Versión: %s", c.Config.Version)
	c.Logger.Info("Perfiles cargados: %d", len(c.Config.Profiles))
	
	for i, profile := range c.Config.Profiles {
		status := "deshabilitado"
		if profile.Enabled {
			status = "habilitado"
		}
		c.Logger.Info("  [%d] %s (%s) - prioridad: %d", 
			i+1, profile.Name, status, profile.Priority)
	}
}

func runHealthCommand(c *core.Core) {
	c.Logger.Info("Iniciando escaneo del sistema...")
	
	// 1. Discovery
	c.Logger.Info("Fase 1: Autodescubrimiento de componentes")
	systemMap, err := discovery.DiscoverSystem(c.Paths.BinDir)
	if err != nil {
		c.Logger.Error("Error en Discovery: %v", err)
		fmt.Fprintf(os.Stderr, `{"error": "discovery_failed", "details": "%s"}`+"\n", err.Error())
		os.Exit(1)
	}
	
	c.Logger.Success("✓ brain.exe: %s", systemMap.BrainPath)
	c.Logger.Success("✓ chrome.exe: %s", systemMap.ChromePath)
	if systemMap.VSCodePlugin != "" {
		c.Logger.Success("✓ VSCode Plugin: %s (v%s)", systemMap.VSCodePlugin, systemMap.PluginVersion)
	} else {
		c.Logger.Warning("VSCode Plugin no encontrado")
	}
	
	// 2. Health Scan
	c.Logger.Info("Fase 2: Auditoría de servicios")
	report, err := health.CheckHealth(systemMap)
	if err != nil {
		c.Logger.Error("Error en Health Scan: %v", err)
		fmt.Fprintf(os.Stderr, `{"error": "health_scan_failed", "details": "%s"}`+"\n", err.Error())
		os.Exit(1)
	}
	
	for _, service := range report.Services {
		if service.Available {
			c.Logger.Success("✓ %s: %s", service.Name, service.Details)
		} else {
			c.Logger.Warning("✗ %s: %s", service.Name, service.Details)
		}
	}
	
	if report.OnboardingCompleted {
		c.Logger.Success("✓ Usuario registrado (onboarding completado)")
	} else {
		c.Logger.Warning("⚠ Onboarding pendiente")
	}
	
	// 3. Persistir en nucleus.json
	c.Logger.Info("Fase 3: Persistiendo estado del sistema")
	if err := persistence.SaveNucleusState(c.Paths.AppDataDir, report); err != nil {
		c.Logger.Error("Error guardando nucleus.json: %v", err)
	} else {
		c.Logger.Success("✓ Estado guardado en nucleus.json")
	}
	
	// 4. JSON Output
	fmt.Println()
	c.Logger.Info("Reporte completo:")
	jsonOutput, _ := json.MarshalIndent(report, "", "  ")
	fmt.Println(string(jsonOutput))
}
```

--------------------------------------------------------------------------------

internal\core\config.go

```go
package core

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

type Profile struct {
	Name     string `json:"name"`
	Path     string `json:"path"`
	Enabled  bool   `json:"enabled"`
	Priority int    `json:"priority"`
}

type Settings struct {
	AutoStart       bool `json:"autoStart"`
	MinimizeToTray  bool `json:"minimizeToTray"`
	CheckInterval   int  `json:"checkInterval"`
	MaxRestarts     int  `json:"maxRestarts"`
	RestartDelay    int  `json:"restartDelay"`
}

type Monitoring struct {
	Enabled         bool `json:"enabled"`
	LogLevel        string `json:"logLevel"`
	MaxLogSize      int  `json:"maxLogSize"`
	MaxLogFiles     int  `json:"maxLogFiles"`
}

type Config struct {
	Version    string     `json:"version"`
	Profiles   []Profile  `json:"profiles"`
	Settings   Settings   `json:"settings"`
	Monitoring Monitoring `json:"monitoring"`
}

func LoadConfig(binDir string) (*Config, error) {
	blueprintPath := filepath.Join(binDir, "blueprint.json")
	
	data, err := os.ReadFile(blueprintPath)
	if err != nil {
		return nil, fmt.Errorf("error al leer blueprint.json: %w", err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("error al parsear blueprint.json: %w", err)
	}

	if len(config.Profiles) == 0 {
		return nil, fmt.Errorf("no se encontraron perfiles en blueprint.json")
	}

	return &config, nil
}
```

--------------------------------------------------------------------------------

internal\core\core.go

```go
package core

import (
	"fmt"
)

type Core struct {
	Paths  *Paths
	Config *Config
	Logger *Logger
}

func Initialize() (*Core, error) {
	paths, err := InitPaths()
	if err != nil {
		return nil, fmt.Errorf("error al inicializar rutas: %w", err)
	}

	logger, err := InitLogger(paths.LogsDir)
	if err != nil {
		return nil, fmt.Errorf("error al inicializar logger: %w", err)
	}

	config, err := LoadConfig(paths.BinDir)
	if err != nil {
		logger.Close()
		return nil, fmt.Errorf("error al cargar configuración: %w", err)
	}

	core := &Core{
		Paths:  paths,
		Config: config,
		Logger: logger,
	}

	return core, nil
}

func (c *Core) Close() error {
	if c.Logger != nil {
		return c.Logger.Close()
	}
	return nil
}
```

--------------------------------------------------------------------------------

internal\core\logger.go

```go
package core

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"
)

type Logger struct {
	file   *os.File
	logger *log.Logger
}

func InitLogger(logsDir string) (*Logger, error) {
	now := time.Now()
	logFileName := fmt.Sprintf("sentinel_%s.log", now.Format("2006-01-02"))
	logFilePath := filepath.Join(logsDir, logFileName)

	file, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		return nil, fmt.Errorf("error al crear archivo de log: %w", err)
	}

	multiWriter := io.MultiWriter(os.Stdout, file)
	logger := log.New(multiWriter, "", log.Ldate|log.Ltime)

	return &Logger{
		file:   file,
		logger: logger,
	}, nil
}

func (l *Logger) Info(format string, v ...interface{}) {
	msg := fmt.Sprintf("[INFO] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Error(format string, v ...interface{}) {
	msg := fmt.Sprintf("[ERROR] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Warning(format string, v ...interface{}) {
	msg := fmt.Sprintf("[WARNING] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Success(format string, v ...interface{}) {
	msg := fmt.Sprintf("[SUCCESS] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Close() error {
	if l.file != nil {
		return l.file.Close()
	}
	return nil
}
```

--------------------------------------------------------------------------------

internal\core\paths.go

```go
package core

import (
	"os"
	"path/filepath"
	"strings"
)

type Paths struct {
	BinDir      string
	AppDataDir  string
	ProfilesDir string
	LogsDir     string
}

func InitPaths() (*Paths, error) {
	exe, err := os.Executable()
	if err != nil {
		return nil, err
	}
	binDir := filepath.Dir(exe)

	// Ruta absoluta a AppData/Local/BloomNucleus
	localAppData := os.Getenv("LOCALAPPDATA")
	if localAppData == "" {
		localAppData = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local")
	}
	appDataDir := filepath.Join(localAppData, "BloomNucleus")

	paths := &Paths{
		BinDir:      binDir,
		AppDataDir:  appDataDir,
		ProfilesDir: filepath.Join(appDataDir, "profiles"),
		LogsDir:     filepath.Join(appDataDir, "logs"),
	}

	// Forzar creación de directorios
	dirs := []string{paths.AppDataDir, paths.ProfilesDir, paths.LogsDir}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, err
		}
	}

	return paths, nil
}

func (p *Paths) String() string {
	var sb strings.Builder
	sb.WriteString("Rutas del Sistema:\n")
	sb.WriteString("  BinDir:      " + p.BinDir + "\n")
	sb.WriteString("  AppDataDir:  " + p.AppDataDir + "\n")
	sb.WriteString("  ProfilesDir: " + p.ProfilesDir + "\n")
	sb.WriteString("  LogsDir:     " + p.LogsDir + "\n")
	return sb.String()
}
```

--------------------------------------------------------------------------------

internal\discovery\discovery.go

```go
package discovery

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type SystemMap struct {
	BrainPath      string `json:"brain_path"`
	ChromePath     string `json:"chrome_path"`
	VSCodePlugin   string `json:"vscode_plugin"`
	PluginVersion  string `json:"plugin_version"`
}

type VSCodePackage struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func DiscoverSystem(binDir string) (*SystemMap, error) {
	sm := &SystemMap{}
	localAppData := os.Getenv("LOCALAPPDATA")
	if localAppData == "" {
		localAppData = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local")
	}

	// 1. Rutas precisas requeridas
	sm.BrainPath = filepath.Join(localAppData, "BloomNucleus", "bin", "brain", "brain.exe")
	sm.ChromePath = filepath.Join(localAppData, "BloomNucleus", "bin", "chrome-win", "chrome.exe")

	// Validación de existencia
	if _, err := os.Stat(sm.BrainPath); err != nil {
		return nil, fmt.Errorf("brain.exe no encontrado en: %s", sm.BrainPath)
	}

	// 2. Scanner de VSCode
	pluginPath, version, _ := scanVSCode(os.Getenv("USERPROFILE"))
	sm.VSCodePlugin = pluginPath
	sm.PluginVersion = version

	return sm, nil
}

func scanVSCode(userProfile string) (string, string, error) {
	extDir := filepath.Join(userProfile, ".vscode", "extensions")
	entries, err := os.ReadDir(extDir)
	if err != nil {
		return "", "", err
	}

	for _, entry := range entries {
		if entry.IsDir() && strings.Contains(strings.ToLower(entry.Name()), "josevigil.bloom-nucleus-installer") {
			path := filepath.Join(extDir, entry.Name())
			pkgData, err := os.ReadFile(filepath.Join(path, "package.json"))
			if err != nil {
				continue
			}
			var pkg VSCodePackage
			json.Unmarshal(pkgData, &pkg)
			if strings.Contains(strings.ToLower(pkg.Name), "bloom-nucleus") {
				return path, pkg.Version, nil
			}
		}
	}
	return "", "", fmt.Errorf("plugin no encontrado")
}
```

--------------------------------------------------------------------------------

internal\health\health.go

```go
package health

import (
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/exec"
	"sentinel/internal/discovery"
	"sync"
	"time"
)

type ServiceStatus struct {
	Name      string `json:"name"`
	Available bool   `json:"available"`
	Details   string `json:"details,omitempty"`
}

type HealthReport struct {
	Timestamp           string                  `json:"timestamp"`
	SystemMap           *discovery.SystemMap    `json:"system_map"`
	ExecutablesValid    bool                    `json:"executables_valid"`
	Services            []ServiceStatus         `json:"services"`
	OnboardingCompleted bool                  `json:"onboarding_completed"`
}

func CheckHealth(sm *discovery.SystemMap) (*HealthReport, error) {
	report := &HealthReport{
		Timestamp: time.Now().Format(time.RFC3339),
		SystemMap: sm,
	}

	// Verificar ejecutables
	_, errB := os.Stat(sm.BrainPath)
	report.ExecutablesValid = (errB == nil)

	// Escaneo de Red Concurrente
	var wg sync.WaitGroup
	results := make(chan ServiceStatus, 2)

	wg.Add(2)
	go func() {
		defer wg.Done()
		results <- checkTCP(5678, "Brain TCP Service")
	}()
	go func() {
		defer wg.Done()
		results <- checkHTTP(3001, "Chrome Extension Backend")
	}()

	go func() {
		wg.Wait()
		close(results)
	}()

	for res := range results {
		report.Services = append(report.Services, res)
	}

	// Check Lógico Onboarding
	if report.ExecutablesValid {
		cmd := exec.Command(sm.BrainPath, "--json", "health", "onboarding-status")
		out, err := cmd.Output()
		if err == nil {
			var resp struct {
				Onboarding struct{ Completed bool } `json:"onboarding"`
			}
			json.Unmarshal(out, &resp)
			report.OnboardingCompleted = resp.Onboarding.Completed
		}
	}

	return report, nil
}

func checkTCP(port int, name string) ServiceStatus {
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("127.0.0.1:%d", port), 1*time.Second)
	if err != nil {
		return ServiceStatus{Name: name, Available: false, Details: "Puerto cerrado"}
	}
	conn.Close()
	return ServiceStatus{Name: name, Available: true, Details: "OK"}
}

func checkHTTP(port int, name string) ServiceStatus {
	client := http.Client{Timeout: 1 * time.Second}
	resp, err := client.Get(fmt.Sprintf("http://127.0.0.1:%d/health", port))
	if err != nil || resp.StatusCode != 200 {
		return ServiceStatus{Name: name, Available: false, Details: "Inalcanzable"}
	}
	defer resp.Body.Close()
	return ServiceStatus{Name: name, Available: true, Details: "HTTP 200"}
}
```

--------------------------------------------------------------------------------

internal\persistence\persistence.go

```go
package persistence

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sentinel/internal/health"
)

type NucleusState struct {
	LastScan            string                `json:"last_scan"`
	Paths               *PathsInfo            `json:"paths"`
	Services            []health.ServiceStatus `json:"services"`
	OnboardingCompleted bool                  `json:"onboarding_completed"`
}

type PathsInfo struct {
	BrainPath     string `json:"brain_path"`
	ChromePath    string `json:"chrome_path"`
	VSCodePlugin  string `json:"vscode_plugin,omitempty"`
	PluginVersion string `json:"plugin_version,omitempty"`
}

func SaveNucleusState(appDataDir string, report *health.HealthReport) error {
	configDir := filepath.Join(appDataDir, "config")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("error creando directorio config: %w", err)
	}
	
	state := &NucleusState{
		LastScan: report.Timestamp,
		Paths: &PathsInfo{
			BrainPath:     report.SystemMap.BrainPath,
			ChromePath:    report.SystemMap.ChromePath,
			VSCodePlugin:  report.SystemMap.VSCodePlugin,
			PluginVersion: report.SystemMap.PluginVersion,
		},
		Services:            report.Services,
		OnboardingCompleted: report.OnboardingCompleted,
	}
	
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return fmt.Errorf("error serializando estado: %w", err)
	}
	
	nucleusPath := filepath.Join(configDir, "nucleus.json")
	if err := os.WriteFile(nucleusPath, data, 0644); err != nil {
		return fmt.Errorf("error escribiendo nucleus.json: %w", err)
	}
	
	return nil
}

func LoadNucleusState(appDataDir string) (*NucleusState, error) {
	nucleusPath := filepath.Join(appDataDir, "config", "nucleus.json")
	
	data, err := os.ReadFile(nucleusPath)
	if err != nil {
		return nil, fmt.Errorf("error leyendo nucleus.json: %w", err)
	}
	
	var state NucleusState
	if err := json.Unmarshal(data, &state); err != nil {
		return nil, fmt.Errorf("error parseando nucleus.json: %w", err)
	}
	
	return &state, nil
}
```

--------------------------------------------------------------------------------

