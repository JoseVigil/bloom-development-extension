main.go

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"sentinel/internal/core"
	"sentinel/internal/discovery"
	"sentinel/internal/health"
	"sentinel/internal/persistence"
)

func main() {
	c, err := core.Initialize()
	if err != nil {
		fmt.Fprintf(os.Stderr, "✗ Error fatal: %v\n", err)
		os.Exit(1)
	}
	defer c.Close()

	// Verificar si se pasó el comando "health"
	if len(os.Args) > 1 && os.Args[1] == "health" {
		runHealthCommand(c)
		return
	}

	// Comportamiento por defecto (inicialización base)
	c.Logger.Success("Sentinel Base Inicializada con éxito")
	fmt.Println()
	
	fmt.Print(c.Paths.String())
	fmt.Println()
	
	c.Logger.Success("Todas las rutas validadas correctamente")
	
	c.Logger.Info("Versión: %s", c.Config.Version)
	c.Logger.Info("Perfiles cargados: %d", len(c.Config.Profiles))
	
	for i, profile := range c.Config.Profiles {
		status := "deshabilitado"
		if profile.Enabled {
			status = "habilitado"
		}
		c.Logger.Info("  [%d] %s (%s) - prioridad: %d", 
			i+1, profile.Name, status, profile.Priority)
	}
}

func runHealthCommand(c *core.Core) {
	c.Logger.Info("Iniciando escaneo del sistema...")
	
	// 1. Discovery
	c.Logger.Info("Fase 1: Autodescubrimiento de componentes")
	systemMap, err := discovery.DiscoverSystem(c.Paths.BinDir)
	if err != nil {
		c.Logger.Error("Error en Discovery: %v", err)
		fmt.Fprintf(os.Stderr, `{"error": "discovery_failed", "details": "%s"}`+"\n", err.Error())
		os.Exit(1)
	}
	
	c.Logger.Success("✓ brain.exe: %s", systemMap.BrainPath)
	c.Logger.Success("✓ chrome.exe: %s", systemMap.ChromePath)
	if systemMap.VSCodePlugin != "" {
		c.Logger.Success("✓ VSCode Plugin: %s (v%s)", systemMap.VSCodePlugin, systemMap.PluginVersion)
	} else {
		c.Logger.Warning("VSCode Plugin no encontrado")
	}
	
	// 2. Health Scan
	c.Logger.Info("Fase 2: Auditoría de servicios")
	report, err := health.CheckHealth(systemMap)
	if err != nil {
		c.Logger.Error("Error en Health Scan: %v", err)
		fmt.Fprintf(os.Stderr, `{"error": "health_scan_failed", "details": "%s"}`+"\n", err.Error())
		os.Exit(1)
	}
	
	for _, service := range report.Services {
		if service.Available {
			c.Logger.Success("✓ %s: %s", service.Name, service.Details)
		} else {
			c.Logger.Warning("✗ %s: %s", service.Name, service.Details)
		}
	}
	
	if report.OnboardingCompleted {
		c.Logger.Success("✓ Usuario registrado (onboarding completado)")
	} else {
		c.Logger.Warning("⚠ Onboarding pendiente")
	}
	
	// 3. Persistir en nucleus.json
	c.Logger.Info("Fase 3: Persistiendo estado del sistema")
	if err := persistence.SaveNucleusState(c.Paths.AppDataDir, report); err != nil {
		c.Logger.Error("Error guardando nucleus.json: %v", err)
	} else {
		c.Logger.Success("✓ Estado guardado en nucleus.json")
	}
	
	// 4. JSON Output
	fmt.Println()
	c.Logger.Info("Reporte completo:")
	jsonOutput, _ := json.MarshalIndent(report, "", "  ")
	fmt.Println(string(jsonOutput))
}
```

--------------------------------------------------------------------------------

internal\core\config.go

```go
package core

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

type Profile struct {
	Name     string `json:"name"`
	Path     string `json:"path"`
	Enabled  bool   `json:"enabled"`
	Priority int    `json:"priority"`
}

type Settings struct {
	AutoStart       bool `json:"autoStart"`
	MinimizeToTray  bool `json:"minimizeToTray"`
	CheckInterval   int  `json:"checkInterval"`
	MaxRestarts     int  `json:"maxRestarts"`
	RestartDelay    int  `json:"restartDelay"`
}

type Monitoring struct {
	Enabled         bool `json:"enabled"`
	LogLevel        string `json:"logLevel"`
	MaxLogSize      int  `json:"maxLogSize"`
	MaxLogFiles     int  `json:"maxLogFiles"`
}

type Config struct {
	Version    string     `json:"version"`
	Profiles   []Profile  `json:"profiles"`
	Settings   Settings   `json:"settings"`
	Monitoring Monitoring `json:"monitoring"`
}

func LoadConfig(binDir string) (*Config, error) {
	blueprintPath := filepath.Join(binDir, "blueprint.json")
	
	data, err := os.ReadFile(blueprintPath)
	if err != nil {
		return nil, fmt.Errorf("error al leer blueprint.json: %w", err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("error al parsear blueprint.json: %w", err)
	}

	if len(config.Profiles) == 0 {
		return nil, fmt.Errorf("no se encontraron perfiles en blueprint.json")
	}

	return &config, nil
}
```

--------------------------------------------------------------------------------

internal\core\core.go

```go
package core

import (
	"fmt"
)

type Core struct {
	Paths  *Paths
	Config *Config
	Logger *Logger
}

func Initialize() (*Core, error) {
	paths, err := InitPaths()
	if err != nil {
		return nil, fmt.Errorf("error al inicializar rutas: %w", err)
	}

	logger, err := InitLogger(paths.LogsDir)
	if err != nil {
		return nil, fmt.Errorf("error al inicializar logger: %w", err)
	}

	config, err := LoadConfig(paths.BinDir)
	if err != nil {
		logger.Close()
		return nil, fmt.Errorf("error al cargar configuración: %w", err)
	}

	core := &Core{
		Paths:  paths,
		Config: config,
		Logger: logger,
	}

	return core, nil
}

func (c *Core) Close() error {
	if c.Logger != nil {
		return c.Logger.Close()
	}
	return nil
}
```

--------------------------------------------------------------------------------

internal\core\logger.go

```go
package core

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"
)

type Logger struct {
	file   *os.File
	logger *log.Logger
}

func InitLogger(logsDir string) (*Logger, error) {
	now := time.Now()
	logFileName := fmt.Sprintf("sentinel_%s.log", now.Format("2006-01-02"))
	logFilePath := filepath.Join(logsDir, logFileName)

	file, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		return nil, fmt.Errorf("error al crear archivo de log: %w", err)
	}

	multiWriter := io.MultiWriter(os.Stdout, file)
	logger := log.New(multiWriter, "", log.Ldate|log.Ltime)

	return &Logger{
		file:   file,
		logger: logger,
	}, nil
}

func (l *Logger) Info(format string, v ...interface{}) {
	msg := fmt.Sprintf("[INFO] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Error(format string, v ...interface{}) {
	msg := fmt.Sprintf("[ERROR] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Warning(format string, v ...interface{}) {
	msg := fmt.Sprintf("[WARNING] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Success(format string, v ...interface{}) {
	msg := fmt.Sprintf("[SUCCESS] "+format, v...)
	l.logger.Println(msg)
}

func (l *Logger) Close() error {
	if l.file != nil {
		return l.file.Close()
	}
	return nil
}
```

--------------------------------------------------------------------------------

internal\core\paths.go

```go
package core

import (
	"os"
	"path/filepath"
	"strings"
)

type Paths struct {
	BinDir      string
	AppDataDir  string
	ProfilesDir string
	LogsDir     string
}

func InitPaths() (*Paths, error) {
	exe, err := os.Executable()
	if err != nil {
		return nil, err
	}

	binDir := filepath.Dir(exe)
	var appDataDir string

	baseName := filepath.Base(binDir)
	if baseName == "win32" || baseName == "darwin" {
		appDataDir = filepath.Dir(binDir)
	} else {
		localAppData := os.Getenv("LOCALAPPDATA")
		if localAppData == "" {
			localAppData = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local")
		}
		appDataDir = filepath.Join(localAppData, "BloomNucleus")
	}

	paths := &Paths{
		BinDir:      binDir,
		AppDataDir:  appDataDir,
		ProfilesDir: filepath.Join(appDataDir, "profiles"),
		LogsDir:     filepath.Join(appDataDir, "logs"),
	}

	dirs := []string{paths.AppDataDir, paths.ProfilesDir, paths.LogsDir}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, err
		}
	}

	return paths, nil
}

func (p *Paths) String() string {
	var sb strings.Builder
	sb.WriteString("Rutas del Sistema:\n")
	sb.WriteString("  BinDir:      " + p.BinDir + "\n")
	sb.WriteString("  AppDataDir:  " + p.AppDataDir + "\n")
	sb.WriteString("  ProfilesDir: " + p.ProfilesDir + "\n")
	sb.WriteString("  LogsDir:     " + p.LogsDir + "\n")
	return sb.String()
}
```

--------------------------------------------------------------------------------

internal\discovery\discovery.go

```go
package discovery

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type SystemMap struct {
	BrainPath      string `json:"brain_path"`
	ChromePath     string `json:"chrome_path"`
	VSCodePlugin   string `json:"vscode_plugin"`
	PluginVersion  string `json:"plugin_version"`
}

type VSCodePackage struct {
	Name        string `json:"name"`
	DisplayName string `json:"displayName"`
	Version     string `json:"version"`
}

func DiscoverSystem(binDir string) (*SystemMap, error) {
	sm := &SystemMap{}
	
	// 1. Búsqueda de brain.exe
	brainPath, err := findBinary("brain.exe", binDir)
	if err != nil {
		return nil, fmt.Errorf("brain.exe no encontrado: %w", err)
	}
	sm.BrainPath = brainPath
	
	// 2. Búsqueda de chrome.exe
	chromePath, err := findBinary("chrome.exe", binDir)
	if err != nil {
		return nil, fmt.Errorf("chrome.exe no encontrado: %w", err)
	}
	sm.ChromePath = chromePath
	
	// 3. Búsqueda del plugin de VSCode
	pluginPath, version, err := findVSCodePlugin()
	if err != nil {
		// No es error crítico si no se encuentra el plugin
		sm.VSCodePlugin = ""
		sm.PluginVersion = ""
	} else {
		sm.VSCodePlugin = pluginPath
		sm.PluginVersion = version
	}
	
	return sm, nil
}

func findBinary(binaryName string, binDir string) (string, error) {
	// Prioridad 1: Misma carpeta que Sentinel (binDir)
	localPath := filepath.Join(binDir, binaryName)
	if fileExists(localPath) && isExecutable(localPath) {
		return localPath, nil
	}
	
	// Prioridad 2: Rutas estándar en AppData
	localAppData := os.Getenv("LOCALAPPDATA")
	if localAppData == "" {
		localAppData = filepath.Join(os.Getenv("USERPROFILE"), "AppData", "Local")
	}
	
	appDataPaths := []string{
		filepath.Join(localAppData, "BloomNucleus", "bin", binaryName),
		filepath.Join(localAppData, "BloomNucleus", binaryName),
		filepath.Join(localAppData, "Programs", "BloomNucleus", binaryName),
	}
	
	for _, path := range appDataPaths {
		if fileExists(path) && isExecutable(path) {
			return path, nil
		}
	}
	
	return "", fmt.Errorf("binario %s no encontrado en ninguna ubicación", binaryName)
}

func findVSCodePlugin() (string, string, error) {
	userProfile := os.Getenv("USERPROFILE")
	if userProfile == "" {
		return "", "", fmt.Errorf("variable USERPROFILE no definida")
	}
	
	extensionsDir := filepath.Join(userProfile, ".vscode", "extensions")
	if !fileExists(extensionsDir) {
		return "", "", fmt.Errorf("directorio de extensiones de VSCode no existe")
	}
	
	entries, err := os.ReadDir(extensionsDir)
	if err != nil {
		return "", "", fmt.Errorf("error al leer directorio de extensiones: %w", err)
	}
	
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		
		dirName := entry.Name()
		if strings.Contains(strings.ToLower(dirName), "josevigil.bloom-nucleus-installer") {
			pluginPath := filepath.Join(extensionsDir, dirName)
			packageJSONPath := filepath.Join(pluginPath, "package.json")
			
			if !fileExists(packageJSONPath) {
				continue
			}
			
			// Leer y validar package.json
			data, err := os.ReadFile(packageJSONPath)
			if err != nil {
				continue
			}
			
			var pkg VSCodePackage
			if err := json.Unmarshal(data, &pkg); err != nil {
				continue
			}
			
			// Validar que sea el plugin correcto
			if strings.Contains(strings.ToLower(pkg.Name), "bloom-nucleus") {
				return pluginPath, pkg.Version, nil
			}
		}
	}
	
	return "", "", fmt.Errorf("plugin JoseVigil.bloom-nucleus-installer no encontrado")
}

func fileExists(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return !info.IsDir()
}

func isExecutable(path string) bool {
	// En Windows, validamos que tenga extensión .exe
	return strings.HasSuffix(strings.ToLower(path), ".exe")
}
```

--------------------------------------------------------------------------------

internal\health\health.go

```go
package health

import (
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os/exec"
	"sentinel/internal/discovery"
	"sync"
	"time"
)

type ServiceStatus struct {
	Name      string `json:"name"`
	Available bool   `json:"available"`
	Details   string `json:"details,omitempty"`
}

type HealthReport struct {
	Timestamp           string                  `json:"timestamp"`
	SystemMap           *discovery.SystemMap    `json:"system_map"`
	ExecutablesValid    bool                    `json:"executables_valid"`
	Services            []ServiceStatus         `json:"services"`
	OnboardingCompleted bool                    `json:"onboarding_completed"`
}

type BrainHealthResponse struct {
	Status     string `json:"status"`
	Onboarding struct {
		Completed bool `json:"completed"`
	} `json:"onboarding"`
}

func CheckHealth(sm *discovery.SystemMap) (*HealthReport, error) {
	report := &HealthReport{
		Timestamp:        time.Now().Format(time.RFC3339),
		SystemMap:        sm,
		ExecutablesValid: false,
		Services:         []ServiceStatus{},
		OnboardingCompleted: false,
	}
	
	// 1. Validar que los ejecutables existan y sean válidos
	report.ExecutablesValid = validateExecutables(sm)
	
	// 2. Escaneo de servicios de red (concurrente)
	var wg sync.WaitGroup
	servicesChan := make(chan ServiceStatus, 2)
	
	wg.Add(2)
	go func() {
		defer wg.Done()
		servicesChan <- checkTCPPort(5678, "Brain TCP Service")
	}()
	
	go func() {
		defer wg.Done()
		servicesChan <- checkHTTPHealth(3001, "Chrome Extension Backend")
	}()
	
	go func() {
		wg.Wait()
		close(servicesChan)
	}()
	
	for service := range servicesChan {
		report.Services = append(report.Services, service)
	}
	
	// 3. Check lógico de onboarding
	if report.ExecutablesValid {
		onboardingStatus, err := checkOnboardingStatus(sm.BrainPath)
		if err == nil {
			report.OnboardingCompleted = onboardingStatus
		}
	}
	
	return report, nil
}

func validateExecutables(sm *discovery.SystemMap) bool {
	if sm.BrainPath == "" || sm.ChromePath == "" {
		return false
	}
	
	// Verificar que brain.exe sea ejecutable
	cmd := exec.Command(sm.BrainPath, "--version")
	if err := cmd.Run(); err != nil {
		return false
	}
	
	return true
}

func checkTCPPort(port int, serviceName string) ServiceStatus {
	address := fmt.Sprintf("localhost:%d", port)
	conn, err := net.DialTimeout("tcp", address, 2*time.Second)
	
	if err != nil {
		return ServiceStatus{
			Name:      serviceName,
			Available: false,
			Details:   fmt.Sprintf("Puerto %d cerrado o inaccesible", port),
		}
	}
	
	conn.Close()
	return ServiceStatus{
		Name:      serviceName,
		Available: true,
		Details:   fmt.Sprintf("Puerto %d abierto", port),
	}
}

func checkHTTPHealth(port int, serviceName string) ServiceStatus {
	url := fmt.Sprintf("http://localhost:%d/health", port)
	client := &http.Client{
		Timeout: 2 * time.Second,
	}
	
	resp, err := client.Get(url)
	if err != nil {
		return ServiceStatus{
			Name:      serviceName,
			Available: false,
			Details:   fmt.Sprintf("HTTP GET a /health falló: %v", err),
		}
	}
	defer resp.Body.Close()
	
	if resp.StatusCode == 200 {
		return ServiceStatus{
			Name:      serviceName,
			Available: true,
			Details:   fmt.Sprintf("HTTP 200 OK en puerto %d", port),
		}
	}
	
	return ServiceStatus{
		Name:      serviceName,
		Available: false,
		Details:   fmt.Sprintf("HTTP %d en puerto %d", resp.StatusCode, port),
	}
}

func checkOnboardingStatus(brainPath string) (bool, error) {
	cmd := exec.Command(brainPath, "--json", "health", "onboarding-status")
	
	output, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("error ejecutando brain.exe: %w", err)
	}
	
	var response BrainHealthResponse
	if err := json.Unmarshal(output, &response); err != nil {
		return false, fmt.Errorf("error parseando respuesta JSON: %w", err)
	}
	
	return response.Onboarding.Completed, nil
}
```

--------------------------------------------------------------------------------

internal\persistence\persistence.go

```go
package persistence

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sentinel/internal/discovery"
	"sentinel/internal/health"
)

type NucleusState struct {
	LastScan            string                `json:"last_scan"`
	Paths               *PathsInfo            `json:"paths"`
	Services            []health.ServiceStatus `json:"services"`
	OnboardingCompleted bool                  `json:"onboarding_completed"`
}

type PathsInfo struct {
	BrainPath     string `json:"brain_path"`
	ChromePath    string `json:"chrome_path"`
	VSCodePlugin  string `json:"vscode_plugin,omitempty"`
	PluginVersion string `json:"plugin_version,omitempty"`
}

func SaveNucleusState(appDataDir string, report *health.HealthReport) error {
	configDir := filepath.Join(appDataDir, "config")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("error creando directorio config: %w", err)
	}
	
	state := &NucleusState{
		LastScan: report.Timestamp,
		Paths: &PathsInfo{
			BrainPath:     report.SystemMap.BrainPath,
			ChromePath:    report.SystemMap.ChromePath,
			VSCodePlugin:  report.SystemMap.VSCodePlugin,
			PluginVersion: report.SystemMap.PluginVersion,
		},
		Services:            report.Services,
		OnboardingCompleted: report.OnboardingCompleted,
	}
	
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return fmt.Errorf("error serializando estado: %w", err)
	}
	
	nucleusPath := filepath.Join(configDir, "nucleus.json")
	if err := os.WriteFile(nucleusPath, data, 0644); err != nil {
		return fmt.Errorf("error escribiendo nucleus.json: %w", err)
	}
	
	return nil
}

func LoadNucleusState(appDataDir string) (*NucleusState, error) {
	nucleusPath := filepath.Join(appDataDir, "config", "nucleus.json")
	
	data, err := os.ReadFile(nucleusPath)
	if err != nil {
		return nil, fmt.Errorf("error leyendo nucleus.json: %w", err)
	}
	
	var state NucleusState
	if err := json.Unmarshal(data, &state); err != nil {
		return nil, fmt.Errorf("error parseando nucleus.json: %w", err)
	}
	
	return &state, nil
}
```

--------------------------------------------------------------------------------

