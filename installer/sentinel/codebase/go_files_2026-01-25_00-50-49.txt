main.go

```go
package main

import (
	"os"
	"sentinel/internal/core"
	"sentinel/internal/startup"
	"github.com/spf13/cobra"

	// Estos imports activan el auto-descubrimiento. 
	// No los borres aunque parezca que no se usan, el "_" es para eso.
	_ "sentinel/internal/boot"
	_ "sentinel/internal/bridge"
	_ "sentinel/internal/health"
	_ "sentinel/internal/ignition"
	_ "sentinel/internal/seed"
	_ "sentinel/internal/ui"
)

func main() {
	// 1. InicializaciÃ³n del Core
	c, err := core.Initialize()
	if err != nil {
		os.Exit(1)
	}
	defer c.Close()

	// 2. Fase Startup
	if err := startup.Initialize(c); err != nil {
		c.Logger.Error("Fallo crÃ­tico en fase Startup: %v", err)
		os.Exit(1)
	}

	// 3. Comando RaÃ­z
	rootCmd := &cobra.Command{
		Use:   "sentinel",
		Short: "Sentinel Base v" + c.Config.Version,
		Run: func(cmd *cobra.Command, args []string) {
			c.Logger.Success("Sentinel Base v%s activa y sincronizada.", c.Config.Version)
		},
	}

	// 4. IntegraciÃ³n de comandos registrados en internal/
	for _, factory := range core.CommandRegistry {
		rootCmd.AddCommand(factory(c))
	}

	// 5. EjecuciÃ³n
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

// RPCRequest define la estructura de comandos entrantes desde Electron
type RPCRequest struct {
	Method string          `json:"method"`
	Params json.RawMessage `json:"params"`
}

// ============================================================================
// BRAIN SERVICE MANAGEMENT
// ============================================================================

// checkBrainHealth verifica que Brain Service estÃ© realmente funcional
func checkBrainHealth(c *core.Core) error {
	c.Logger.Info("ðŸ” Verificando Brain Service...")
	
	// Intento 1: Check TCP bÃ¡sico
	conn, err := net.DialTimeout("tcp", "127.0.0.1:5678", 2*time.Second)
	if err != nil {
		return fmt.Errorf("Brain Service no responde en puerto 5678: %w", err)
	}
	conn.Close()
	
	c.Logger.Success("âœ“ Brain Service detectado en puerto 5678")
	
	// Intento 2: Validar que acepte conexiones (enviar ping simple)
	conn, err = net.Dial("tcp", "127.0.0.1:5678")
	if err != nil {
		return fmt.Errorf("No se puede establecer conexiÃ³n con Brain: %w", err)
	}
	defer conn.Close()
	
	// Enviar mensaje de prueba (protocolo Brain: 4 bytes length + JSON)
	testMsg := []byte(`{"type":"HEALTH_PING"}`)
	length := uint32(len(testMsg))
	header := []byte{
		byte(length >> 24),
		byte(length >> 16),
		byte(length >> 8),
		byte(length),
	}
	
	conn.SetWriteDeadline(time.Now().Add(1 * time.Second))
	if _, err := conn.Write(append(header, testMsg...)); err != nil {
		return fmt.Errorf("Brain no acepta mensajes: %w", err)
	}
	
	c.Logger.Success("âœ“ Brain Service OPERATIVO")
	return nil
}

// startBrainService intenta arrancar Brain Service si no estÃ¡ corriendo
func startBrainService(c *core.Core) error {
	c.Logger.Info("ðŸš€ Iniciando Brain Service...")
	
	// Buscar el ejecutable de Brain
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	brainExe := sm.BrainPath
	
	if brainExe == "" || !fileExists(brainExe) {
		return fmt.Errorf("brain.exe no encontrado en: %s", c.Paths.BinDir)
	}
	
	c.Logger.Info("   Ejecutable: %s", brainExe)
	
	// Comando para iniciar Brain Service
	var cmd *exec.Cmd
	
	if runtime.GOOS == "windows" {
		// En Windows, usar start para ejecutar en background
		cmd = exec.Command("cmd", "/C", "start", "/B", brainExe, "service", "start", "--port", "5678")
	} else {
		cmd = exec.Command(brainExe, "service", "start", "--port", "5678", "--daemon")
	}
	
	if err := cmd.Start(); err != nil {
		return fmt.Errorf("No se pudo iniciar Brain: %w", err)
	}
	
	c.Logger.Info("   PID: %d", cmd.Process.Pid)
	
	// Esperar a que el puerto estÃ© disponible (mÃ¡ximo 10 segundos)
	for i := 0; i < 20; i++ {
		time.Sleep(500 * time.Millisecond)
		
		conn, err := net.DialTimeout("tcp", "127.0.0.1:5678", 500*time.Millisecond)
		if err == nil {
			conn.Close()
			c.Logger.Success("âœ“ Brain Service iniciado correctamente")
			return nil
		}
	}
	
	return fmt.Errorf("Brain Service no respondiÃ³ despuÃ©s de 10 segundos")
}

// ensureBrainRunning garantiza que Brain estÃ© operativo o falla
func ensureBrainRunning(c *core.Core) error {
	// Intento 1: Â¿EstÃ¡ corriendo?
	if err := checkBrainHealth(c); err == nil {
		return nil // Ya estÃ¡ corriendo
	}
	
	c.Logger.Warning("âš ï¸  Brain Service no detectado, intentando iniciar...")
	
	// Intento 2: Arrancarlo
	if err := startBrainService(c); err != nil {
		return fmt.Errorf("CRÃTICO: No se pudo arrancar Brain Service: %w", err)
	}
	
	// Intento 3: Verificar que ahora estÃ© funcionando
	time.Sleep(1 * time.Second)
	if err := checkBrainHealth(c); err != nil {
		return fmt.Errorf("Brain Service arrancÃ³ pero no responde: %w", err)
	}
	
	return nil
}

// ============================================================================
// DEV-START COMMAND (REFACTORED)
// ============================================================================

func runDevStartCommand(c *core.Core) {
	c.Logger.Info("ðŸš€ Iniciando Entorno de Desarrollo Integrado...")

	// âœ… PASO CRÃTICO: Asegurar que Brain estÃ© corriendo PRIMERO
	if err := ensureBrainRunning(c); err != nil {
		c.Logger.Error("âŒ %v", err)
		c.Logger.Error("")
		c.Logger.Error("SOLUCIÃ“N:")
		c.Logger.Error("  1. Verifica que brain.exe exista en: %s", c.Paths.BinDir)
		c.Logger.Error("  2. O inicia Brain manualmente:")
		c.Logger.Error("     brain.exe service start --port 5678")
		c.Logger.Error("")
		os.Exit(1)
	}

	// A. Discovery de herramientas de desarrollo
	codePath, _ := discovery.FindVSCodeBinary()
	extPath := c.Config.Settings.ExtensionPath
	wsPath := c.Config.Settings.TestWorkspace
	runtimePath := filepath.Join(c.Paths.AppDataDir, "resources", "runtime")

	// B. Registro de descubrimientos en nucleus.json
	startup.UpdateActiveStatus(c, map[string]string{
		"vscode_exe":        codePath,
		"vscode_workspace":  wsPath,
		"svelte_app_path":   filepath.Join(extPath, "webview", "app"),
		"operational_mode":  "development",
		"dev_runtime_path":  runtimePath,
		"brain_service":     "running", // âœ… Confirmado
	})

	// C. Lanzamiento de Svelte (Vite)
	svelteCmd, err := boot.LaunchSvelte(extPath)
	if err != nil {
		c.Logger.Warning("No se pudo iniciar Svelte: %v", err)
	}

	// D. SincronizaciÃ³n de Entorno VSCode
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	_ = boot.SyncVScodeSettings(extPath, sm.BrainPath, filepath.Join(runtimePath, "python.exe"))

	// E. Lanzamiento de VSCode Extension Host
	vsCmd, err := boot.LaunchExtensionHost(codePath, extPath, wsPath, runtimePath)
	if err != nil {
		c.Logger.Error("Fallo al lanzar VSCode: %v", err)
		if svelteCmd != nil { boot.KillProcessTree(svelteCmd.Process.Pid) }
		os.Exit(1)
	}

	// F. HEALTH CHECK MEJORADO
	c.Logger.Info("ðŸ” Validando estado del ecosistema...")
	time.Sleep(2 * time.Second)
	
	report, err := health.CheckHealth(c, sm)
	if err != nil {
		c.Logger.Warning("âš ï¸  Health check reportÃ³ errores: %v", err)
	} else {
		c.Logger.Success("âœ“ Estado del sistema actualizado en nucleus.json")
	}
	
	// Guardar estado actualizado
	persistence.SaveNucleusState(c, report)

	// G. Manejo de terminaciÃ³n
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	
	c.Logger.Info("")
	c.Logger.Success(">>> Entorno LISTO. Presiona Ctrl+C para cerrar todo.")
	c.Logger.Info("")
	<-sigs 

	fmt.Println()
	c.Logger.Info("ðŸ›‘ Finalizando procesos de desarrollo...")
	boot.KillProcessTree(vsCmd.Process.Pid)
	if svelteCmd != nil { boot.KillProcessTree(svelteCmd.Process.Pid) }
	boot.CleanPorts([]int{5173, 3001, 5678})
	c.Logger.Success("âœ“ Sistema limpio.")
}

// ============================================================================
// OTHER COMMANDS (Sin cambios)
// ============================================================================

func runSeedCommand(c *core.Core, alias string, isMaster bool) {
	uuid, err := seed.HandleSeed(c, alias, isMaster)
	if err != nil {
		res, _ := json.Marshal(map[string]string{"status": "error", "message": err.Error()})
		fmt.Println(string(res))
		os.Exit(1)
	}
	
	res, _ := json.Marshal(map[string]interface{}{
		"status": "success", 
		"uuid":   uuid, 
		"alias":  alias,
		"master": isMaster,
	})
	fmt.Println(string(res))
}

func runBridgeMode(c *core.Core) {
	c.Logger.Info("ðŸ“¡ Modo Bridge Activo (Esperando comandos JSON)")
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		var req RPCRequest
		if err := json.Unmarshal(scanner.Bytes(), &req); err != nil {
			sendError("JSON_PARSE_ERROR", err.Error())
			continue
		}

		switch req.Method {
		case "seed":
			var params struct { Alias string; Master bool }
			json.Unmarshal(req.Params, &params)
			uuid, err := seed.HandleSeed(c, params.Alias, params.Master)
			if err != nil {
				sendError("SEED_ERROR", err.Error())
			} else {
				sendResponse(map[string]string{"status": "success", "uuid": uuid})
			}
		case "health":
			sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
			report, _ := health.CheckHealth(c, sm)
			sendResponse(report)
		case "ping":
			sendResponse("pong")
		default:
			sendError("UNKNOWN_METHOD", req.Method)
		}
	}
}

func sendResponse(data interface{}) {
	res, _ := json.Marshal(map[string]interface{}{"result": data})
	fmt.Println(string(res))
}

func sendError(code, msg string) {
	res, _ := json.Marshal(map[string]interface{}{
		"error": map[string]string{"code": code, "message": msg},
	})
	fmt.Println(string(res))
}

func runHealthCommand(c *core.Core) {
	c.Logger.Info("ðŸ” Iniciando escaneo de integridad...")
	
	// âœ… Verificar Brain PRIMERO
	if err := checkBrainHealth(c); err != nil {
		c.Logger.Error("âŒ Brain Service: %v", err)
	} else {
		c.Logger.Success("âœ“ Brain Service: Operativo")
	}
	
	sm, _ := discovery.DiscoverSystem(c.Paths.BinDir)
	report, err := health.CheckHealth(c, sm)
	if err != nil {
		c.Logger.Error("Error en Health: %v", err)
		return
	}
	
	// Sincronizar con el estado persistente
	persistence.SaveNucleusState(c, report)
	
	out, _ := json.MarshalIndent(report, "", "  ")
	fmt.Println(string(out))
}

func runLaunchCommand(c *core.Core, profileID string, mode string) {
	c.Logger.Info("ðŸ”¥ Sentinel Ignition: Perfil %s", profileID)
	
	// âœ… PRE-FLIGHT CHECK: Verificar Brain antes de lanzar
	if err := checkBrainHealth(c); err != nil {
		c.Logger.Error("âŒ PRE-FLIGHT FAILED: %v", err)
		c.Logger.Error("")
		c.Logger.Error("Brain Service debe estar corriendo antes de lanzar perfiles.")
		c.Logger.Error("Ejecuta: brain.exe service start --port 5678")
		c.Logger.Error("")
		os.Exit(1)
	}
	
	ig := ignition.New(c)
	ig.SetupReaper()
	
	if err := ig.Launch(profileID, mode); err != nil {
		c.Logger.Error("Fallo de lanzamiento: %v", err)
		os.Exit(1)
	}
	
	// Bloqueo para mantener la telemetrÃ­a viva hasta que el Reaper actÃºe
	select {} 
}

// ============================================================================
// HELPERS
// ============================================================================

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// ============================================================================
// UI COCKPIT
// ============================================================================

func runCockpit(c *core.Core) {
	// 1. Determinar el modo (default: log)
	mode := "log"
	if len(os.Args) > 2 && os.Args[2] == "--health" {
		mode = "health"
	}

	// 2. DelegaciÃ³n absoluta al orquestador modular
	ui.Launch(c, mode)
}
```

--------------------------------------------------------------------------------

